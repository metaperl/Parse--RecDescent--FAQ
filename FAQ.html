<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Parse::RecDescent::FAQ - the official, authorized FAQ for Parse::RecDescent.</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#overviewtype_questions">OVERVIEW-TYPE QUESTIONS</a></li>
	<ul>

		<li><a href="#is_parse__recdescent_ll_1__ll_n__lr_1__lr_n_">Is Parse::RecDescent LL(1)? LL(N)? LR(1)? LR(N)?</a></li>
	</ul>

	<li><a href="#debugging">DEBUGGING</a></li>
	<ul>

		<li><a href="#flags_you_can_set">Flags you can set</a></li>
		<li><a href="#making_warning_line_numbers_correspond_to_your_grammar">Making warning line numbers correspond to your grammar</a></li>
		<ul>

			<li><a href="#solution_1">Solution 1</a></li>
			<li><a href="#solution_2">Solution 2</a></li>
		</ul>

	</ul>

	<li><a href="#parser_behavior">PARSER BEHAVIOR</a></li>
	<ul>

		<li><a href="#insuring_a_toplevel_rule_match">Insuring a top-level rule match</a></li>
		<ul>

			<li><a href="#answer_by_randal_l__schwartz">Answer by Randal L. Schwartz</a></li>
		</ul>

		<li><a href="#floating_or_substring_matches">Floating or Substring Matches</a></li>
		<li><a href="#backtracking">Backtracking</a></li>
		<ul>

			<li><a href="#and_the_answer_is___">And the answer is...</a></li>
		</ul>

		<li><a href="#skipping_over_things">Skipping over things</a></li>
		<ul>

			<li><a href="#quoting_within_a_skip_expression_">Quoting within a skip expression:</a></li>
			<ul>

				<li><a href="#and_here_s_why_">and here's why:</a></li>
			</ul>

		</ul>

		<li><a href="#leftrecursion">Left-recursion</a></li>
		<li><a href="#commit_in_subrule_which_is_optional_in_rule">Commit in subrule which is optional in rule</a></li>
		<ul>

			<li><a href="#answer_by_damian">Answer by Damian</a></li>
			<li><a href="#now_that_you_think_you_know_the_answer___">Now that you think you know the answer...</a></li>
			<ul>

				<li><a href="#marcel_went_on_to_point_out_an_optimization_">Marcel went on to point out an optimization:</a></li>
			</ul>

		</ul>

	</ul>

	<li><a href="#ignorable_tokens">IGNORABLE TOKENS</a></li>
	<ul>

		<li><a href="#removing_c_comments">Removing C comments</a></li>
	</ul>

	<li><a href="#newline_processing">NEWLINE PROCESSING</a></li>
	<ul>

		<li><a href="#parsing_windows_init___ini__files">Parsing Windows Init (.ini) Files</a></li>
		<li><a href="#as_end_of_line">As end of line</a></li>
		<ul>

			<li><a href="#example_in_a_linedelimited_grammar">Example In a line-delimited grammar</a></li>
		</ul>

	</ul>

	<li><a href="#columnoriented_processing">COLUMN-ORIENTED PROCESSING</a></li>
	<ul>

		<li><a href="#whitespace__text__column_n__period__number__some_reference_to_lookahead_">Whitespace, text, column N, period, number (some reference to lookahead)</a></li>
		<li><a href="#another_example">Another example</a></li>
	</ul>

	<li><a href="#parsing_quotes_within______quotes_">Parsing Quotes within .... Quotes!</a></li>
	<li><a href="#modular___generative___creative___hairy_parsing">MODULAR / GENERATIVE / CREATIVE / HAIRY PARSING</a></li>
	<ul>

		<li><a href="#subrule_matches_n_times__where_n_is_parsed_on_the_fly">Subrule matches N times, where N is parsed on the fly</a></li>
		<li><a href="#rulebuilding_by_interpolating_an_array_of_choices">Rule-building by interpolating an array of choices</a></li>
		<li><a href="#macro_processing">Macro processing</a></li>
		<li><a href="#cloning_parsers_but_giving_each_parser_it_own_package">Cloning parsers but giving each parser it own package</a></li>
		<li><a href="#parsing_sentences_to_generate_sentences">Parsing sentences to generate sentences</a></li>
		<li><a href="#calling_a_parser_within_a_grammar">Calling a parser within a grammar</a></li>
		<li><a href="#incremental_generation_of_data_structure_representing_parse">Incremental generation of data structure representing parse</a></li>
		<li><a href="#xor_as_opposed_ior_alternation_matching">XOR as opposed IOR alternation matching</a></li>
	</ul>

	<li><a href="#cleaning_up_your_grammars">CLEANING UP YOUR GRAMMARS</a></li>
	<ul>

		<li><a href="#use_repetition_modifiers_with_a_separator_pattern_to_match">Use repetition modifiers with a separator pattern to match</a></li>
	</ul>

	<li><a href="#optimizing_your_grammars">OPTIMIZING YOUR GRAMMARS</a></li>
	<ul>

		<li><a href="#dan_sugalski_s_practice_and_theory_of_optimizing_prd_grammars">Dan Sugalski's Practice and Theory of Optimizing PRD Grammars</a></li>
		<li><a href="#eliminate_backtracking_when_possible">Eliminate backtracking when possible</a></li>
		<li><a href="#precompiling_grammars_for_speed_of_execution">Precompiling Grammars for Speed of Execution</a></li>
		<li><a href="#parse__recdescent_is_slow_on_really_big_files__how_can_i_speed_it_up">Parse::RecDescent is slow on Really Big Files. How can I speed it up?</a></li>
	</ul>

	<li><a href="#capturing_matches">CAPTURING MATCHES</a></li>
	<ul>

		<li><a href="#hey__i_m_getting_back_array_0x355300__instead_of_what_i_set__return_to_">Hey! I'm getting back <code>ARRAY(0x355300)</code> instead of what I set $return to!</a></li>
		<li><a href="#getting_text_from_subrule_matches">Getting text from subrule matches</a></li>
		<li><a href="#capturing_whitespace_between_tokens">Capturing whitespace between tokens</a></li>
		<li><a href="#my_grammar_is_not_returning_any_data_">My grammar is not returning any data!</a></li>
	</ul>

	<li><a href="#things_not_to_do">THINGS NOT TO DO</a></li>
	<ul>

		<li><a href="#don_t_think_that_rule__statement_and_rule__statement_1__are_the">Don't think that rule: statement and rule: <code>statement(1)</code> are the</a></li>
		<li><a href="#do_not_follow__resync__with__reject__to_skip_errors">Do not follow &lt;resync&gt; with &lt;reject&gt; to skip errors</a></li>
		<li><a href="#do_not_assume_that__item_contains_an_array_ref_of_all_text_matched_for">Do not assume that %item contains an array ref of all text matched for</a></li>
		<li><a href="#use__rulevar__local__x__not__rulevar___x_">use &lt;rulevar: local $x&gt; not &lt;rulevar: $x&gt;</a></li>
		<li><a href="#don_t_use____rd_autoaction_to_print_while_you_are_parsing">Don't use $::RD_AUTOACTION to print while you are parsing</a></li>
	</ul>

	<li><a href="#error_handling">ERROR HANDLING</a></li>
	<ul>

		<li><a href="#propagating_a_failure_up_after_a__commit__on_a_subrule">Propagating a failure up after a &lt;commit&gt; on a subrule</a></li>
		<li><a href="#in_a_nonshell__e_g__cgi__environment">In a non-shell (e.g. CGI) environment</a></li>
		<li><a href="#accessing_error_data">Accessing error data</a></li>
		<li><a href="#simple_error_handling">Simple Error Handling</a></li>
		<li><a href="#collecting_all_error_messages_for_processing">Collecting all error messages for processing</a></li>
	</ul>

	<li><a href="#other_parse__recdescent_questions">OTHER Parse::RecDescent QUESTIONS</a></li>
	<ul>

		<li><a href="#how_to_get_the_old_perl_com_article_to_work">How to get the old perl.com article to work?</a></li>
		<li><a href="#matching_line_continuation_characters">Matching line continuation characters</a></li>
		<li><a href="#how_can_i_match_parenthetical_expressions_to_arbitrary_depth">How can I match parenthetical expressions to arbitrary depth?</a></li>
		<li><a href="#switching_out_of_firstmatchwins_mode">Switching out of first-match-wins mode</a></li>
		<li><a href="#i_m_having_problems_with_the_intertoken_separator_">I'm having problems with the inter-token separator:</a></li>
		<li><a href="#matching_blank_lines">Matching blank lines</a></li>
		<li><a href="#how_can_i_get_at_the_text_remaining_to_be_parsed">How can I get at the text remaining to be parsed?</a></li>
		<li><a href="#you_don_t_escape_perl_symbols_in_your_grammars__why_did_i_have_to">You don't escape Perl symbols in your grammars. Why did I have to?</a></li>
		<li><a href="#other_modules_appear_to_not_work_when_used_with_p__rd">Other modules appear to not work when used with P::RD</a></li>
	</ul>

	<li><a href="#programming_topics_germane_to_parse__recdescent_use">PROGRAMMING TOPICS GERMANE TO Parse::RecDescent USE</a></li>
	<ul>

		<li><a href="#getting_large_files_into_memory">Getting large files into memory</a></li>
		<li><a href="#double_vs_singlequoted_strings">Double vs Single-quoted strings</a></li>
		<li><a href="#tracking_text_parsed_between_phases_of_the_parse">Tracking text parsed between phases of the parse</a></li>
		<li><a href="#unconditionally_listifying_scalars">Unconditionally listifying scalars</a></li>
		<li><a href="#shallow_versus_deep_copying">Shallow versus Deep Copying</a></li>
		<ul>

			<li><a href="#an_article_by_randal_schwartz">An article by Randal Schwartz</a></li>
			<li><a href="#a_tutorial_written_by_philip_newton__nospam_newton_gmx_li_">A tutorial written by Philip Newton &lt;<a href="mailto:nospam.newton@gmx.li">nospam.newton@gmx.li</a>&gt;</a></li>
		</ul>

		<li><a href="#apparent__but_not_really_deep_copying__my___list____________0_____">Apparent, but not really deep copying:  my (@list) = @{[@{$_[0]}]};</a></li>
		<li><a href="#regular_expressions">Regular Expressions</a></li>
		<ul>

			<li><a href="#shortest_match_instead_of_longest_match">Shortest match instead of longest match</a></li>
			<li><a href="#tutorial_on_positive_and_negative_lookahead_and_lookbehind">Tutorial on positive and negative lookahead and lookbehind</a></li>
			<li><a href="#japhy_s_book_on_regular_expressions">Japhy's Book on Regular Expressions</a></li>
			<li><a href="#mastering_regular_expressions_by_jeffrey_freidl">``Mastering Regular Expressions'' by Jeffrey Freidl</a></li>
		</ul>

	</ul>

	<li><a href="#perlmonks_nodes">Perlmonks Nodes</a></li>
	<li><a href="#resources">RESOURCES</a></li>
	<ul>

		<li><a href="#web_links">Web Links</a></li>
		<ul>

			<li><a href="#some_parse__recdescent_tutorials">``Some Parse::RecDescent Tutorials''</a></li>
			<li><a href="#craig_s_parse__recdescent_area">Craig's Parse::Recdescent Area</a></li>
			<li><a href="#parse__recdescent_tutorial_at_www_perl_com">Parse::Recdescent tutorial at www.perl.com</a></li>
		</ul>

		<li><a href="#published_articles_and_books">Published articles and books</a></li>
		<ul>

			<li><a href="#parse_data__dumper_output">Parse Data::Dumper output</a></li>
			<li><a href="#parsing_interesting_things">``Parsing Interesting Things''</a></li>
			<li><a href="#data_munging_with_perl_by_dave_cross">``Data Munging with Perl'' by Dave Cross</a></li>
			<li><a href="#objectoriented_perl_by_damian_conway">``Object-Oriented Perl'' by Damian Conway</a></li>
		</ul>

		<li><a href="#cpan_modules_of_wonderful_utility_">CPAN Modules of Wonderful Utility!</a></li>
		<ul>

			<li><a href="#data__match">Data::Match</a></li>
			<li><a href="#data__multivaluedhash">Data::MultiValuedHash</a></li>
			<li><a href="#parse__recdescent__consumer">Parse::RecDescent::Consumer</a></li>
			<li><a href="#regexp__list__part_of_regexp__optimizer_">Regexp::List (part of Regexp::Optimizer)</a></li>
			<li><a href="#regexp_assemble">Regexp:Assemble</a></li>
			<li><a href="#text__balanced_and_regexp__common__balanced">Text::Balanced  and Regexp::Common::balanced</a></li>
			<li><a href="#scalar__listify">Scalar::Listify</a></li>
		</ul>

		<li><a href="#practical_parser_examples">Practical Parser Examples</a></li>
		<ul>

			<li><a href="#dbfeeder___data__generate__database_test_data_generation_tool">DBFeeder / Data::Generate - database test data generation tool</a></li>
			<ul>

				<li><a href="#tangential_new_directions">Tangential new directions</a></li>
			</ul>

			<li><a href="#article_comparing_gene_parsing_with_prd_and_other_approaches">Article comparing Gene Parsing with PRD and other approaches</a></li>
			<li><a href="#module_dependency_expression_parser">Module dependency expression parser</a></li>
			<li><a href="#xsh__the_xml_editing_shell">XSH - The XML Editing Shell</a></li>
			<li><a href="#parsing_symbolic_expressions___boolean_logic">Parsing Symbolic Expressions / Boolean Logic</a></li>
			<li><a href="#mysql_to_oracle_schema_conversion_utility">MySql to Oracle schema conversion utility</a></li>
		</ul>

		<li><a href="#other_parsing_engines">Other Parsing Engines</a></li>
		<ul>

			<li><a href="#py">py</a></li>
			<li><a href="#parse__yapp">Parse::YAPP</a></li>
			<li><a href="#parse__earley">Parse::Earley</a></li>
			<li><a href="#perl6__rules">Perl6::Rules</a></li>
			<li><a href="#perlbyacc">perl-byacc</a></li>
			<li><a href="#domainspecific_parsers">Domain-specific parsers</a></li>
		</ul>

		<li><a href="#a_vim_syntax_file_for_parse__recdescent">a VIM Syntax File for Parse::RecDescent</a></li>
	</ul>

	<li><a href="#appendix">APPENDIX</a></li>
	<ul>

		<li><a href="#author">Author</a></li>
		<li><a href="#sources_for_faq_material">Sources for FAQ Material</a></li>
	</ul>

	<li><a href="#faq_repo">FAQ repo</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>Parse::RecDescent::FAQ - the official, authorized FAQ for Parse::RecDescent.</p>
<p>
</p>
<hr />
<h1><a name="overviewtype_questions">OVERVIEW-TYPE QUESTIONS</a></h1>
<p>
</p>
<h2><a name="is_parse__recdescent_ll_1__ll_n__lr_1__lr_n_">Is Parse::RecDescent LL(1)? LL(N)? LR(1)? LR(N)?</a></h2>
<dl>
<dt><strong><a name="item_answer_by_yves_orton_3a">Answer by Yves Orton:</a></strong>

<dd>
<p>I have a data structure which is</p>
</dd>
<dd>
<p>a hash of entries
where
an entry is a list/array of sets</p>
</dd>
<dd>
<p>I have also a grammar that can parse the syntax of the text files that
contain the data I want to fill this structure with. Until here
everything is ok.</p>
</dd>
<dd>
<p>Problem: I cannot figure out how to actually FILL the parsed data into
the structure. I can only decide if a string is grammatically correct
or not.</p>
</dd>
</li>
</dl>
<p>Also see the ``Left-recursion'' section under <a href="#parser_behavior">PARSER BEHAVIOR</a></p>
<p>
</p>
<hr />
<h1><a name="debugging">DEBUGGING</a></h1>
<p></p>
<p>
</p>
<h2><a name="flags_you_can_set">Flags you can set</a></h2>
<p>Paraphrased from Yves Orton:</p>
<p>To understand more about why your parser is not behaving as it should
take advantage of the follow variables:</p>
<pre>
   $::RD_ERRORS       # unless undefined, report fatal errors
   $::RD_WARN         # unless undefined, also report non-fatal problems
   $::RD_HINT         # if defined, also suggestion remedies
   $::RD_TRACE        # if defined, also trace parsers' behaviour</pre>
<p>
</p>
<h2><a name="making_warning_line_numbers_correspond_to_your_grammar">Making warning line numbers correspond to your grammar</a></h2>
<p>How do I match the line numbers with the actual contents of my
script?</p>
<p>
</p>
<h3><a name="solution_1">Solution 1</a></h3>
<p>(from Holger Helmuth)</p>
<p>A possible solution is to put anything more complicated than a trivial
statement into a subroutine outside of the parser. To call it you have
to qualify it with the package name.</p>
<p>Without this (maybe trivial?) method I probably would have given up on
P:RD on my last project. Disadvantage is that the code is distributed
into two locations and there should be a speed penality too, but it was
definitely worth it.</p>
<p>
</p>
<h3><a name="solution_2">Solution 2</a></h3>
<p>At present, you can't (but that's on the ToDo list).
Setting <code>$::RD_TRACE</code> can be useful though:</p>
<p>Once you've run with <code>$RD_TRACE</code>, do this:</p>
<pre>
        perl -w RD_TRACE</pre>
<p>Then go and examine the actual line numbers given for the error
in the file <code>RD_TRACE</code>.</p>
<p>That will show you the actual generated code that's the problem.</p>
<p>That code will, in turn, give you a hint where the problem is in the
grammar (e.g. find out which subroutine it's in, which will tell you the
name of the offending rule).</p>
<p>
</p>
<hr />
<h1><a name="parser_behavior">PARSER BEHAVIOR</a></h1>
<p>
</p>
<h2><a name="insuring_a_toplevel_rule_match">Insuring a top-level rule match</a></h2>
<p>I have a question regarding subrules within grammars used with
Parse::RecDescent - The following code best illustrates the best test
case that I can identify which highlights my problem.</p>
<p>Note that with this test code, each of the lines within the __DATA__ section are tested against the grammar and the expected result, either pass or fail, is indicated by the 1 or 0 at the start of the line respectively.</p>
<p>However, despite these expected results, the grammar does not reject
the lines arg1, and arg1,arg2,, which ideally should be rejected due
to the incomplete match of the subrule (comma element) - In these
cases, a trace shows that the subrule terminal comma is matched and
consumed, despite the entire subrule, consisting of comma and element,
not being matched. I am sure this is a relatively straight-forward
oversight within the grammar on my part, but I am at a loss as to how
to correct this.</p>
<p>Program fragment delivered error ``couldnt open file : No such file or directory at ./tt.pl line 18, &lt;F&gt; line 14.''</p>
<p>
</p>
<h3><a name="answer_by_randal_l__schwartz">Answer by Randal L. Schwartz</a></h3>
<p>It's matching a portion of the string, which is legal unless you also
anchor the end of the pattern. I typically use <code>/\z/</code> at the end of my
top-level pattern.</p>
<p>Also, your comma-separated string can be parsed simply with</p>
<pre>
 argument: element(s /,/)</pre>
<p>as shown in the P::RD examples on the manpage.</p>
<p>
</p>
<h2><a name="floating_or_substring_matches">Floating or Substring Matches</a></h2>
<p>Oftentimes, you may want to find if a grammar pattern exists anywhere
in the input string, not necessarily right from the start.</p>
<p>In this post:</p>
<p><a href="http://www.mail-archive.com/recdescent@perl.org/msg00499.html">http://www.mail-archive.com/recdescent@perl.org/msg00499.html</a></p>
<p>titled ``Re: floating / backtracking - style match'', Ted Zlatnov 
provides an elegant solution to getting the job done.</p>
<p>
</p>
<h2><a name="backtracking">Backtracking</a></h2>
<p>Take the following regex:</p>
<pre>
  /(aa|a)a/</pre>
<p>It will match this text:</p>
<pre>
  aaa</pre>
<p>Now take the following PRD grammar:</p>
<pre>
 use strict;
 use warnings;
 use Parse::RecDescent;
 
 my $grammar = 'startrule: ( &quot;aa&quot; | &quot;a&quot; ) &quot;a&quot;';
 my $parser  = Parse::RecDescent-&gt;new($grammar);
 my $text    = 'aa';
 
 print defined($parser-&gt;startrule($text)) ? &quot;Good!\n&quot; : &quot;Bad!\n&quot;;</pre>
<p>It *will* print ``Bad'', meaning that PRD did not match it.</p>
<p>The reason is that the first branch of the alternation matched, then the next subrule failed.</p>
<p>You may ask: is there any way to persuade a top-down parser like P::RD
to accept the above text as valid? I know that, in this simple
example, I could easily rewrite the grammar (either by saying</p>
<pre>
 (&quot;a&quot; |&quot;aa&quot; ) &quot;a&quot;</pre>
<p>or</p>
<pre>
 &quot;aa&quot; a&quot; | &quot;a&quot; &quot;a&quot;</pre>
<p>but what I mean is: Is there any
additional feature I have missed which would allow the grammar as is
to parse the text successfully?</p>
<p>To put the question another way, can I get P::RD to behave more like a
regex engine? After all, even an NFA engine would backtrack to try all
possible alternatives before failing :-) (Perhaps parsers just do not
backtrack past individual subrules under any circumstances.)</p>
<p>
</p>
<h3><a name="and_the_answer_is___">And the answer is...</a></h3>
<p>RecDescent parsers do not work that way. They don't backtrack on
failure; they just fail. Of course, there's nothing to prevent a
recursive descent parser from incorporating backtracking too, but
RecDescent doesn't.</p>
<p>So, if you need backtracking in part of your grammar, you need to use
plain old regexes there.</p>
<p>
</p>
<h2><a name="skipping_over_things">Skipping over things</a></h2>
<p>The variable</p>
<pre>
  $Parse::RecDescent::skip</pre>
<p>is what you need. It takes strings and <code>qr</code>-quoted regular expressions.
See the Parse::RecDescent docs for details.</p>
<p>Also, see the <code>Terminal Separators</code> parts of the docs.</p>
<p>Here is an example of removing C comments in program text
(courtesy Damian Conway) by treating them as whitespace!</p>
<pre>
        program: &lt;skip: qr{\s* (/[*] .*? [*]/ \s*)*}x&gt; statement(s)</pre>
<pre>
        statement: # etc...</pre>
<p>However, thanks to Chas Owens, we have an update that works for
him. Instead of just <code>x</code> as a regular expression modifier he had to
add s as well:</p>
<pre>
 program: &lt;skip: qr{\s* (/[*] .*? [*]/ \s*)*}xs&gt; statement(s)</pre>
<p>
</p>
<h3><a name="quoting_within_a_skip_expression_">Quoting within a skip expression:</a></h3>
<p>Here is my script:</p>
<pre>
 ------ Start Script ------
 use strict;
 use warnings;
 
 $::RD_TRACE = 1;
 
 use Parse::RecDescent;
 
 my $grammar = q{
 
    input:  number(s) { $return = $item{ number } } | &lt;error&gt;
 
    number: &lt;skip: '\.*'&gt; /\d+/ 
 
 };</pre>
<pre>
 my $parser = new Parse::RecDescent($grammar);
 
 my $test_string = qq{1.2.3.5.8};</pre>
<pre>
 print join( &quot;\n&quot;, @{ $parser -&gt; input( $test_string ) } );
 ------ End Script ------</pre>
<p>This script works great. However, if I change the value of the skip
directive so that it uses double quotes instead of single quotes:</p>
<pre>
 &lt;skip: &quot;\.*&quot;&gt;</pre>
<p>the grammar fails to parse the input. However, if I put square
brackets around the escaped dot:</p>
<pre>
 &lt;skip: &quot;[\.]*&quot;&gt;</pre>
<p>the grammar starts working again...</p>
<p>
</p>
<h4><a name="and_here_s_why_">and here's why:</a></h4>
<p>This small test program may help you figure out what's going wrong:</p>
<pre>
        print &quot;\.*&quot;, &quot;\n&quot;;
        print '\.*', &quot;\n&quot;;</pre>
<p>Backslash works differently inside single and double quotes.
Try:</p>
<pre>
      &lt;skip: &quot;\\.*&quot;&gt;</pre>
<p>The reason the third variant:</p>
<pre>
      &lt;skip: &quot;[\.]*&quot;&gt;</pre>
<p>works is because it becomes the pattern:</p>
<pre>
        /[.]/</pre>
<p>which is a literal dot.</p>
<p>
</p>
<h2><a name="leftrecursion">Left-recursion</a></h2>
<ul>
<li><strong><a name="item_on_elimination_of_left_2drecursion_randal_schwartz">On elimination of left-recursion Randal Schwartz states:</a></strong>

<p>I had a fun time eliminating a mutual left-recursion problem for
my ``Data-Undumper'' program, which used P::RD as an essential component.
See my discussion of such at</p>
<pre>
 <a href="http://www.stonehenge.com/merlyn/LinuxMag/col29.html">http://www.stonehenge.com/merlyn/LinuxMag/col29.html</a></pre>
</li>
<li><strong><a name="item_also_2c_regarding_elimination_see_this_perlmonks_n">Also, regarding elimination see this Perlmonks node:</a></strong>

<pre>
 <a href="http://www.perlmonks.org/index.pl?lastnode_id=6364&amp;node_id=153155">http://www.perlmonks.org/index.pl?lastnode_id=6364&amp;node_id=153155</a></pre>
<li><strong><a name="item_regarding_detection_of_left_2drecursion_2c_conway_">Regarding detection of left-recursion, Conway states:</a></strong>

<p>RecDescent does a complete graph traversal looking for n-ary
left-recursion loops and fails to compile the grammar if it finds any
left-recursive loop involving any number of rules. It has done this since its
earliest versions.</p>
</li>
</ul>
<p>
</p>
<h2><a name="commit_in_subrule_which_is_optional_in_rule">Commit in subrule which is optional in rule</a></h2>
<p>Ques: When a subrule in a rule that has a ``zero or
more'' repetition specifier (ie. ? or s?) has a
&lt;commit&gt; directive in its production followed by the
conditional &lt;error?&gt; &lt;reject&gt; production, if that
subrule's production becomes committed, does that
error cause the rule containing the subrule to fail
also?  It should right, if we have committed?  It does
not seem to work.</p>
<p>Here is what I mean:</p>
<pre>
 myrule: 'stuff' mysubrule(?)</pre>
<pre>
 mysubrule: ID &lt;commit&gt; '[' ']'
       | &lt;error?&gt; &lt;reject&gt;</pre>
<p>If the 1st production of mysubrule has committed, then
myrule should fail.  It doesn't seem to.  If this is
not a bug, how do I get this behavior?</p>
<p>
</p>
<h3><a name="answer_by_damian">Answer by Damian</a></h3>
<p>The optional nature of the reference to <code>mysubrule(?)</code>
means that, when the subrule fails (whether committed or not)
the failure doesn't matter, since myrule can match if it
finds zero mysubrules, which it just did.</p>
<p>The usual way to get the rule-of-the-subrule to fail upon subrule failure is
by ``anchoring'' the end of the match. That might be:</p>
<pre>
  myrule: 'stuff' mysubrule(?) ...!ID</pre>
<pre>
  mysubrule: ID &lt;commit&gt; '[' ']'
           | &lt;error?&gt; &lt;reject&gt;</pre>
<p>or</p>
<pre>
  myrule: 'stuff' mysubrule(?) /\s*\Z/</pre>
<pre>
  mysubrule: ID &lt;commit&gt; '[' ']'
           | &lt;error?&gt; &lt;reject&gt;</pre>
<p>or whatever addition confirms that there really wasn't anything else
after 'stuff'.</p>
<p>
</p>
<h3><a name="now_that_you_think_you_know_the_answer___">Now that you think you know the answer...</a></h3>
<p>That answer is partially wrong, as was pointed out by Marcel Grunaer.
In this phrase:</p>
<pre>
  myrule: 'stuff' mysubrule(?) ...!ID</pre>
<p>it is necessary to return a { 1 }, as the rule
fails otherwise, presumably because of the negative lookahead:</p>
<pre>
  myrule: 'stuff' mysubrule(?) ...!ID { 1 }</pre>
<p>
</p>
<h4><a name="marcel_went_on_to_point_out_an_optimization_">Marcel went on to point out an optimization:</a></h4>
<p>another option would be the use of a rulevar:</p>
<pre>
  myrule : &lt;rulevar: local $failed&gt;
  myrule : 'stuff' mysubrule(?) &lt;reject:$failed&gt;</pre>
<pre>
  mysubrule: ID &lt;commit&gt; '[' ']'
    | &lt;error?&gt; { $failed++ }</pre>
<p>this way you don't have to specify a potentially complex negative
lookahead, and the method works over several levels of subrules
as well.</p>
<p>
</p>
<hr />
<h1><a name="ignorable_tokens">IGNORABLE TOKENS</a></h1>
<p>
</p>
<h2><a name="removing_c_comments">Removing C comments</a></h2>
<p>Since there is no separate lexer in recdescent. And it is top down. Is
there anyway to deal w/ removing C comments that could be anywhere.</p>
<ul>
<li><strong><a name="item_answer_by_conway">Answer by Conway</a></strong>

<p>Sure. Treat them as whitespace!</p>
<p>Do something like this:</p>
<pre>
        program: &lt;skip: qr{\s* (/[*] .*? [*]/ \s*)*}x&gt; statement(s)</pre>
<pre>
        statement: # etc...</pre>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="newline_processing">NEWLINE PROCESSING</a></h1>
<p>
</p>
<h2><a name="parsing_windows_init___ini__files">Parsing Windows Init (.ini) Files</a></h2>
<p>I'm trying ot use Parse::RecDescent to parse a configuration file which
looks like this:</p>
<pre>
 [SECTION]
 parameter 1=value 1
 parameter2=value 2</pre>
<pre>
 [NEXTSECTION]
 other parameter=other value</pre>
<ul>
<li><strong><a name="item_answer_by_damian">Answer by Damian</a></strong>

<pre>
       q{
                config:
                          section(s)</pre>
<pre>
                section:
                          &lt;skip: ''&gt;  section_label parameter(s)
                        | &lt;error&gt;</pre>
<pre>
                section_label:
                          /\[[A-Z]+\]\s*/</pre>
<pre>
                parameter:
                          key &quot;=&quot; value</pre>
<pre>
                key:
                          /[A-Za-z0-9 ]+/</pre>
<pre>
                value:
                          /.*\n/
        }</pre>
<li><strong><a name="item_another_answer">Another Answer</a></strong>

<p>Also take a look at the example in section 11.2 in ``Data Munging with Perl''
by Dave Cross.</p>
</li>
<li><strong><a name="item_and_the_newest_answer_by_the_tireless_randal_l_2e_">And the newest answer by the tireless Randal L. Schwartz:</a></strong>

<pre>
  L&lt;<a href="http://www.stonehenge.com/merlyn/UnixReview/col40.html&gt">http://www.stonehenge.com/merlyn/UnixReview/col40.html&gt</a>;</pre>
<li><strong><a name="item_and_this_question_pops_up_again_on_perlmonks_2007_">And this question pops up again on perlmonks 2007-08-16:</a></strong>

<pre>
  L&lt;<a href="http://perlmonks.org/?node_id=632838&gt">http://perlmonks.org/?node_id=632838&gt</a>;</pre>
</ul>
<p>
</p>
<h2><a name="as_end_of_line">As end of line</a></h2>
<p>I'm trying to parse a text line by line using Parse::RecDescent. Each
line is terminated by a ``\n''.</p>
<p>Although the task setting up a grammar for this case is straightforward
the following program doesn't
produce any results.</p>
<pre>
     use Parse::RecDescent;</pre>
<pre>
     $grammar =
     q{
         line:       word(s) newline { print &quot;Found a line\n&quot;; }
         word:       /\w+/
         newline : /\n/
     };</pre>
<pre>
     $parse = new Parse::RecDescent ($grammar);</pre>
<pre>
     $data =
     qq(This is line one\nAnd this is line two\n);</pre>
<pre>
     $parse-&gt;line($data);</pre>
<p>RecDescent doesn't recognize the newlines. Does anybody know what I'm
getting wrong?</p>
<ul>
<li><strong>Answer by Damian</strong>

<p>By default, P::RD skips all whitespace (*including* newlines) before
tokens.</p>
<p>Try this instead:</p>
<pre>
         line:    &lt;skip: qr/[ \t]*/&gt; word(s) newline 
                                { print &quot;Found a line\n&quot;; }
         word:    /\w+/
         newline: /\n/</pre>
</li>
</ul>
<p>
</p>
<h3><a name="example_in_a_linedelimited_grammar">Example In a line-delimited grammar</a></h3>
<pre>
 I want to use Parse::RecDescent to parse a certain assembly language. In assembly, data is &quot;line oriented&quot;, that is newline is the statement separator. Simplified demonstration:
 
 command1 arg1 \n
 command2 arg2 \n
 
 Defines two statements. More than one statement on a line is illegal, a statement broken to two lines is also illegal.
 
 Now, P::RD has an issue with newlines. It swallows them by default. There is a workaround using the &quot;skip&quot; directive, but it became tedious and my grammar code is full of &lt;skip: qr/ \t*/&gt; directives.
 
 Is there an easier way ?
 
 What I want, for starters, is a trivial &quot;command arg&quot; pairs for statements:
 
 line -&gt; command arg &quot;\n&quot;</pre>
<ul>
<li><strong><a name="item_answer_by_damian_3a">Answer by Damian:</a></strong>

<pre>
 &lt;skip&gt; tells RecDescent what to skip before trying each 
 terminal. Normally that's any optional whitespace matched by the 
 pattern C&lt;/\s*/&gt;. 
  
 But, if newlines (which would normally be skipped by the above 
 pattern) are significant in your syntax, then you need to change the 
 skipping pattern so that RecDescent doesn't skip newlines. And then 
 match the newlines explicitly. 
  
 For example: 
  
      program : &lt;skip: qr/[^\S\n]/&gt;    # Ignore non-newline whitespace 
                statement(s) 
  
      statement : command arg(s) &quot;\n&quot; 
  
      command: /\w+/ 
  
      args  :  /\d+/ | alphanum 
  
      alphanum :  /[A-Za-z0-9/</pre>
</ul>
<p>
</p>
<hr />
<h1><a name="columnoriented_processing">COLUMN-ORIENTED PROCESSING</a></h1>
<p>
</p>
<h2><a name="whitespace__text__column_n__period__number__some_reference_to_lookahead_">Whitespace, text, column N, period, number (some reference to lookahead)</a></h2>
<p>Ok, now the line I'm trying to deal with is:</p>
<p>``some amount of
whitespace,
then some text, then starting at column 48 a number, followed by a
period,
followed by another number''.  I want to capture the text (the
``title''),
and the two numbers (major and minor versions)</p>
<ul>
<li><strong><a name="item_answer_by_damian_conway">Answer by Damian Conway</a></strong>

<p>You really do want to use a regex here (to get the
lookahead/backtracking that RecDescent doesn't do).</p>
<pre>
   line: m/^(\s*                        # leading whitespace
              (.*?)                     # the title
              (?:\s+(?=\d+\.\d+\s*$))   # the space preceeding the numbers
            )
            (\d+)                       # the major version number
            \.
            (\d+)                       # the minor version number
         /x
         &lt;reject: length $1 != 47&gt;
         { @{$return}{title major minor)} = ($2,$3,$4) }</pre>
</li>
</ul>
<p>
</p>
<h2><a name="another_example">Another example</a></h2>
<p>I'm parsing some lines where the ``column formatting'' is fixed, i.e. a
particular line might be formally described as ``a single word followed by
some amount of whitespace followed by another word whose first character
begins at column 22''.</p>
<ul>
<li><strong><a name="item_a_simple_answer_that_is_wrong_3a">A simple answer that is wrong:</a></strong>

<p>Hmm, I guess I could make this simpler and do this:</p>
<p>line: word &lt;reject: $thiscolumn != 22&gt; word
word: /\S+/</p>
<p>right?</p>
<p>Wrong. And the reason why is that The</p>
<pre>
  &lt;reject:...&gt;</pre>
<p>won't skip any whitespace after the first word.</p>
<p>You instead would want:</p>
<pre>
        line: word '' &lt;reject: $thiscolumn != 22&gt; word</pre>
</li>
<li><strong><a name="item_restating_it_in_the_positive_can_be_a_gotcha_3a">Restating it in the positive can be a GOTCHA:</a></strong>

<p>I'd state that in the positive instead:</p>
<pre>
    line: word '' { $thiscolumn == 22 } word</pre>
<p>This seems nice and more to the point, but unfortunately a failing conditional 
yields a false value but not necessarily an undef value. So in this case, you
might get back a <code>0</code> from evaluating this conditional, but unfortunately,
that does not lead to failure.</p>
<p>On the other hand, &lt;reject&gt; is exactly the same as the action
 { undef } 
and is guaranteed to make a production fail immediately.</p>
<p>So if you would like to state the test in the positive, then do this:</p>
<pre>
   line: word '' { $thiscolumn == 22 || undef } word</pre>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="parsing_quotes_within______quotes_">Parsing Quotes within .... Quotes!</a></h1>
<p>A recent node on Perlmonks 
<a href="http://perlmonks.org/?node_id=665986|http://perlmonks.org/?node_id=665986">http://perlmonks.org/</a>
had a question on how to parse:</p>
<pre>
    A statement &quot;with a quoted ';'&quot; ;</pre>
<p>The best answer is the <code>perl_quotelike</code> section in the offical docs for
<a href="/Parse/RecDescent.html">Parse::RecDescent</a>. An earlir node on Perlmonks:
<a href="http://perlmonks.org/?node_id=485933|http://perlmonks.org/?node_id=485933">http://perlmonks.org/</a> 
covers the use of <code>perl_quotelike</code> in detail.</p>
<p>
</p>
<hr />
<h1><a name="modular___generative___creative___hairy_parsing">MODULAR / GENERATIVE / CREATIVE / HAIRY PARSING</a></h1>
<p>Be sure to see the example see the <a href="#resources">RESOURCES</a> section at the end
for even more nosebleed parsing examples.</p>
<p>
</p>
<h2><a name="subrule_matches_n_times__where_n_is_parsed_on_the_fly">Subrule matches N times, where N is parsed on the fly</a></h2>
<p>Per this link:</p>
<p><a href="http://perlmonks.org/?node_id=522495">http://perlmonks.org/</a> we have a case where the
future-matching is done as a function of the current matching.</p>
<p>
</p>
<h2><a name="rulebuilding_by_interpolating_an_array_of_choices">Rule-building by interpolating an array of choices</a></h2>
<p>Let's say you had to parse phrases like ``6 red balls''. You see this as
<code>&quot;$quantity $color $item&quot;</code>. Now, the colors which are acceptable for
parsing vary from program to program and so the rule which matches the
colors needs to be variable.</p>
<p>We see a fruitful discussion and solution of this problem here:</p>
<p><a href="http://perlmonks.org/?node_id=384098">http://perlmonks.org/</a></p>
<p>
</p>
<h2><a name="macro_processing">Macro processing</a></h2>
<p>In a RecDescent grammar, I'd like to add support in my language for
``macros''.  These macros would be very much like #define macros in C
and would support arguments that are instantiated into the
expansion. In C, this looks something like:</p>
<pre>
 #define   add(a,b)        (a+b)</pre>
<p>In my language, I'd like something like:</p>
<pre>
 myMacro(x,y):        any_expression</pre>
<p>where ``any_expression'' is any old (deep) expression defined elsewhere
in the grammar, and <code>(x,y)</code> would be replaced/instantiated in that
expression.  
This may seem straighforward, but, well, it ain't to me. (I am, after
all, mush4brains.)  In my P::RD grammar, the ``macro'' rule without
arguments would look like:</p>
<pre>
 macro:         identifier ':' expr</pre>
<p>where, again, expr is defined fully in the grammar. Adding arguments
to this... I need to instantiate my <code>(x,y)</code> into the ``expr'' string
before the subrules interpret it.  
Now... I thought of using standard Perl substitution in a pre-scan,
but this seems less-than-ideal, since it requires some knowledge of
the grammar in the Perl REs. I thought of using two separate grammars,
the first of which is a simplified version of the full second grammar,
but this also seems a bit redundant.</p>
<ul>
<li><strong><a name="item_and_the_answer_is_2e_2e_2e">And the answer is...</a></strong>

<pre>
 <a href="http://perlmonks.org/index.pl?node_id=176399">http://perlmonks.org/index.pl?node_id=176399</a></pre>
</ul>
<p>
</p>
<h2><a name="cloning_parsers_but_giving_each_parser_it_own_package">Cloning parsers but giving each parser it own package</a></h2>
<p>It seems that the namespace for pre-compiled parsers
(ie. compiled into a perl module) have hard-coded
namespaces (IE. namespace00001).  I was trying to
clone one of these parsers by calling its 'new'
method, but each parser is sharing the same namespace
and thus any global variables I have in that namespace
within a startcode block of my grammar before the
first rule get overwritten by the other corresponding
parser.</p>
<ul>
<li><strong><a name="item_answer_by_yves_orton">Answer by Yves Orton</a></strong>

<p>Heres the required patch</p>
<pre>
 # Line 1692 of Parse::RecDescent reads</pre>
<pre>
 my $nextnamespace = &quot;namespace000001&quot;;</pre>
<pre>
 # Add This Method
 sub set_namespace {
   local $_=$_[1];
   croak &quot;$_ is not a legal namespace.&quot; if /[^\w]/;
   $_.=&quot;00&quot; unless /\d+$/; # Ensure our namespace has a number at the end
   $nextnamespace=$_;
 }</pre>
<pre>
 # And then just call
 Parse::RecDescent-&gt;set_namespace(&quot;MyNameSpace&quot;);</pre>
</li>
</ul>
<p>
</p>
<h2><a name="parsing_sentences_to_generate_sentences">Parsing sentences to generate sentences</a></h2>
<p>In this column, Randal shows how to read text to generate more text.
He parses sentences to make Parse::RecDescent parse trees which he then
re-walks with random weightings to create new sentences.</p>
<pre>
 <a href="http://www.stonehenge.com/merlyn/LinuxMag/col04.html">http://www.stonehenge.com/merlyn/LinuxMag/col04.html</a></pre>
<p>
</p>
<h2><a name="calling_a_parser_within_a_grammar">Calling a parser within a grammar</a></h2>
<p>I have a script that uses Parse::RecDescent, in which I want to define 2
parsers. The grammar for the second parser has to call the first parser.</p>
<p>Can I do this?</p>
<ul>
<li><strong><a name="item_yes_2c_here_27s_an_example">yes, here's an example</a></strong>

<pre>
 
 #!/usr/local/bin/perl -w
 use strict;
 use Parse::RecDescent;
 
 $::RD_ERRORS = 1;
 $::RD_WARN = 1;
 $::RD_HINT = 1;
 
 our $text_to_parse = &quot;&quot;;
 
 my $grammar1 = q{
 [...]
 }
 
 our $inner_parser = new Parse::RecDescent($grammar1);
 
 my $grammar2 = q{
 [...]
 
 rule: TEXT
        {
          $text_to_parse = $item{TEXT};
           if (defined $text_to_parse) { print &quot;executing inner parse...\n&quot;; }
           my $p_text = $inner_parser-&gt;startrule($text_to_parse);
        }
 
 [...]
 
 }</pre>
</ul>
<p>
</p>
<h2><a name="incremental_generation_of_data_structure_representing_parse">Incremental generation of data structure representing parse</a></h2>
<p>I have a data structure which is</p>
<p>a hash of entries
where
an entry is a list/array of sets</p>
<p>I have also a grammar that can parse the syntax of the text files that
contain the data I want to fill this structure with. Until here
everything is ok.</p>
<p>Problem: I cannot figure out how to actually FILL the parsed data into
the structure. I can only decide if a string is grammatically correct
or not.</p>
<ul>
<li><strong><a name="item_answer_by_marcel_grunaer">Answer by Marcel Grunaer</a></strong>

<p>Try this grammar, which you have to feed the input as one big
string. It uses a global variable, $::res into which the results
are assembled. At the end the variable is also returned for
convenience.</p>
<p>It basically parses a phrase and a list of meanings. Instead of
reconstructing what it just parsed at each step, it checks the
remaining text at various stages (using an idea taken from
Parse::RecDescent::Consumer) to see what the 'phrase' or 'meaning'
subrules just matched. The 'meanings' subrule then (implicitly)
returns a reference to an array of 'meaning' strings. That arrayref
is stored at the proper slot in the result hash.</p>
<p>(Hope that explanation makes sense. I'm sure Damian can come up
with a grammar that's way more elegant and efficient...)</p>
<pre>
 
 
 { sub consumer {
          my $text = shift;
          my $closure = sub { substr $text, 0, length($text) - 
 length($_[0]) }
 } }
 
 start : entry(s) { $::res }
 
 entry :
            comment
          | def
          | &lt;error&gt;
 
 def : &lt;rulevar: local $p_cons&gt;
 def : &lt;rulevar: local $p_text&gt;
 
 # The // skips initial whitespace so it won't end up in $p_text
 
 def :
      // { $p_cons = consumer($text) } phrase { $p_text = 
 $p_cons-&gt;($text) }
      '=' meanings ';'
      { $::res-&gt;{$p_text} = $item{meanings} }
 
 comment : /#.*(?=\n)/m
 
 phrase  : ident(s)
 
 ident   : /[\w&amp;\.'-]+/
 
 meanings : meaning(s /:/)
 
 meaning : &lt;rulevar: local $m_cons&gt;
 meaning : // { $m_cons = consumer($text) } element(s /,?/) 
 { $m_cons-&gt;($text) }
 
 element : alternation(s /\|/)
 
 alternation : expr(s /[+&gt;]/)
 
 expr : /!?/ term
 
 term : ident '(' meaning ')' | ident</pre>
</li>
</ul>
<p>
</p>
<h2><a name="xor_as_opposed_ior_alternation_matching">XOR as opposed IOR alternation matching</a></h2>
<p>I'm using alternations in some productions but in contrast to
the definition of the |-operator, I'm looking for a behaviour
which is XOR (^) not OR (|). So far I used the &lt;reject&gt;
directive to simulate such a behaviour.</p>
<p>Is there any easy solution to this?</p>
<ul>
<li><strong><a name="item_answer_by_randal_schwartz">Answer by Randal Schwartz</a></strong>

<p>Use a set.</p>
<pre>
 use Parse::RecDescent;
 use Data::Dumper; $|++;
 my $parser = Parse::RecDescent-&gt;new(q{
 
 line: word(s) /\z/ {
 my @words = @{$item[1]};
 my %count;
 (grep ++$count{$_} &gt; 1, @words) ? undef : \@words;
 }
 
 word: &quot;one&quot; | &quot;two&quot; | &quot;three&quot;
 
 }) or die;
 
 for (&quot;one two&quot;, &quot;one one&quot;, &quot;two three one&quot;, &quot;three one two one&quot;) {
   print &quot;$_ =&gt;\n&quot;;
   print Dumper($parser-&gt;line($_));
 }
 
 # which generates:
 
 one two =&gt;
   $VAR1 = [
           'one',
           'two'
          ];
 one one =&gt;
   $VAR1 = undef;
 two three one =&gt;
   $VAR1 = [
           'two',
           'three',
           'one'
          ];
 three one two one =&gt;
   $VAR1 = undef;</pre>
</li>
<li><strong><a name="item_embellishment_by_damian_conway">Embellishment by Damian Conway</a></strong>

<p>Furthermore, if uniqueness was something you needed to enforce more
widely
in your grammar, you could factor it out into a parametric rule:</p>
<pre>
        use Parse::RecDescent;
        use Data::Dumper; $|++;
        my $parser = Parse::RecDescent-&gt;new(q{</pre>
<pre>
        line: unique['word'] /\z/ { $return = $item[1] }</pre>
<pre>
        unique: &lt;matchrule: $arg[0]&gt;(s)
            {
              my %seen;
              foreach (@{$item[1]}) { undef $item[1] and last if
$seen{$_}++ }
              $return = $item[1];
            }</pre>
<pre>
        word: &quot;one&quot; | &quot;two&quot; | &quot;three&quot;</pre>
<pre>
        }) or die;</pre>
<pre>
        for (&quot;one two&quot;, &quot;one one&quot;, &quot;two three one&quot;, &quot;three one two
one&quot;) {
          print &quot;$_ =&gt;\n&quot;;
          print Dumper($parser-&gt;line($_));
        }</pre>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="cleaning_up_your_grammars">CLEANING UP YOUR GRAMMARS</a></h1>
<p>In honor of the original (and greatest) Perl book on cleaning up your
Perl code, this section is written in the style of 
Joseph Hall's ``Effective Perl Programming''</p>
<p>
</p>
<h2><a name="use_repetition_modifiers_with_a_separator_pattern_to_match_csvlike_data">Use repetition modifiers with a separator pattern to match
CSV-like data</a></h2>
<p>The intuitive way to match CSV data is this:</p>
<pre>
 CSVLine:
      NonFinalToken(s?) QuotedText
 NonFinalToken: 
      QuotedText Comma
      { $return = $item[1] }</pre>
<p>or, in other (merlyn's) words, ``many comma terminated items followed by
one standalone item''.</p>
<p>Instead, take the approach shown by merlyn:</p>
<pre>
 CSVLine: QuotedText(s Comma) { use Data::Dumper; Dumper($item[1]) }</pre>
<p>Then just define <code>QuotedText</code>, <code>Comma</code>, and you're done!</p>
<p>
</p>
<hr />
<h1><a name="optimizing_your_grammars">OPTIMIZING YOUR GRAMMARS</a></h1>
<p>
</p>
<h2><a name="dan_sugalski_s_practice_and_theory_of_optimizing_prd_grammars">Dan Sugalski's Practice and Theory of Optimizing PRD Grammars</a></h2>
<p>This link is excellent. So excellent in fact, that I took the time to mirror
it to my site to avoid it ever being lost:</p>
<p><a href="http://www.urth.org/~metaperl/domains/semantic-elements.com/perl/prd/dans-blog/000235.html">http://www.urth.org/~metaperl/domains/semantic-elements.com/perl/prd/dans-blog/000235.html</a></p>
<p>This link provides an excellent discussion of hits and misses in optimizing a
grammar whose initial parse time started out at around minutes. After whittling
it down to 5 minutes, Dan is still not happy and continues with even
more aggressive optimizations! Well worth the read.</p>
<p>
</p>
<h2><a name="eliminate_backtracking_when_possible">Eliminate backtracking when possible</a></h2>
<p>Let's take a look at two computationally equivalent grammars:</p>
<pre>
 expression      :       unary_expr PLUS_OP expression
                 |       unary_expr</pre>
<p>versus</p>
<pre>
 expression      :       unary_expr plus_expression
 plus_expression :       PLUS_OP expression
                 |       # nothing</pre>
<p>The second one is more efficient because it does not have to do backtracking.</p>
<p>The first one is more readable and more maintainable though. It is more 
readable because it doesnt have an empty rule. It is more maintainable because
as you add more expression types (minus_expression,
mult_expression...) you don't have to add an empty rule to each of
them. The top level description scales without change.</p>
<p>But, if speed is what you want then the second one is the way to go.</p>
<p>
</p>
<h2><a name="precompiling_grammars_for_speed_of_execution">Precompiling Grammars for Speed of Execution</a></h2>
<p>Take a look at Parse::RecDescent's precompilation option under the section
titled ``Precompiling parsers''.</p>
<p>
</p>
<h2><a name="parse__recdescent_is_slow_on_really_big_files__how_can_i_speed_it_up">Parse::RecDescent is slow on Really Big Files. How can I speed it up?</a></h2>
<ul>
<li><strong><a name="item_reduce_the__22depth_22_of_the_grammar_2e_use_fewer">Reduce the ``depth'' of the grammar. Use fewer levels
of nested subrules.</a></strong>

<li><strong><a name="item_where_possible_2c_use_regex_terminals_instead_of_s">Where possible, use regex terminals instead of subrules.  For 
example, instead of:</a></strong>

<pre>
                string: '&quot;' char(s?) '&quot;'</pre>
<pre>
                char:   /[^&quot;\\]/
                    |   '\\&quot;'
                    |   '\\\\'</pre>
<p>write:</p>
<pre>
                string: /&quot;([^&quot;\\]|\\[&quot;\\])*&quot;/</pre>
<li><strong><a name="item_where_possible_2c_use_string_terminals_instead_of_">Where possible, use string terminals instead of regexes.</a></strong>

<li><strong><a name="item_use_repetitions_or__3cleftop_3e_2f_3crightop_3e_in">Use repetitions or &lt;leftop&gt;/&lt;rightop&gt; instead of recursion.</a></strong>

<p>For example, instead of:</p>
<pre>
                list:  '(' elems ')'
                elems: elem ',' elems
                     | elem</pre>
<p>write:</p>
<pre>
                list: '(' &lt;leftop: elem ',' elem&gt; ')'</pre>
<p>or:</p>
<pre>
                list: '('  elem(s /,/)  ')'</pre>
</li>
<li><strong><a name="item_factor_out_common_prefixes_in_a_set_of_alternate_p">Factor out common prefixes in a set of alternate productions.</a></strong>

<p>For example, instead of:
</p>
<pre>

                id: name rank serial_num
                  | name rank hair_colour
                  | name rank shoe_size</pre>
<p>write:
</p>
<pre>

                id: name rank (serial_num | haircolour | shoe_size)</pre>
</li>
<li><strong><a name="item_pre_2dparse_the_input_somehow_to_break_it_into_sma">Pre-parse the input somehow to break it into smaller sections.
Parse each section separately.</a></strong>

<li><strong><a name="item_grammars">Precompile they grammar. This won't speed up the parsing, but it
will speed up the parser construction for big grammars (which
Really Big Files often require).</a></strong>

<li><strong><a name="item_consider_whether_you_would_be_better_porting_your_">Consider whether you would be better porting your grammar to
Parse::Yapp instead.</a></strong>

</ul>
<p>
</p>
<hr />
<h1><a name="capturing_matches">CAPTURING MATCHES</a></h1>
<p>
</p>
<h2><a name="hey__i_m_getting_back_array_0x355300__instead_of_what_i_set__return_to_">Hey! I'm getting back <code>ARRAY(0x355300)</code> instead of what I set $return to!</a></h2>
<p>Here's a prime example of when this mistake is made:</p>
<pre>
 QuotedText: 
       DoubleQuote TextChar(s?) DoubleQuote
       { my $chars = scalar(@item) - 1;  
         $return = join ('', @item[2..$chars]) }</pre>
<p>This rule is incorrectly written. The author thinks that <code>@item</code> will
have one <a href="#item_textchar"><code>TextChar</code></a> from position 2 until all <a href="#item_textchar"><code>TextChar</code></a>s are matched.
However, the true structure of <code>@item</code> is:</p>
<dl>
<dt><strong><a name="item_position_one_3a_the_string_matched_by_rule_doubleq">position one: the string matched by rule DoubleQuote</a></strong>

<dt><strong><a name="item_textchar">position two: array reference representing parse tree for <code>TextChar(s?)</code></a></strong>

<dt><strong><a name="item_position_three_3a_the_string_matched_by_rule_doubl">position three: the string matched by rule DoubleQuote</a></strong>

</dl>
<p>Note that position two is an array reference. So the rule must be
rewritten in this way.</p>
<pre>
 QuotedText: 
       DoubleQuote TextChar(s?) DoubleQuote
       { $return = join ( '', @{$item[2]} ) }</pre>
<p>
</p>
<h2><a name="getting_text_from_subrule_matches">Getting text from subrule matches</a></h2>
<p>I can't seem to get the text from my subrule matches...</p>
<ul>
<li><strong>Answer by Damian Conway</strong>

<p>Your problem is in this rule:</p>
<pre>
    tuple : (number dot)(2)</pre>
<p>is the same as:</p>
<pre>
    tuple        : anon_subrule(2)</pre>
<pre>
    anon_subrule : number dot</pre>
<p>Like all subrules, this anonymous subrule returns only its last item
(namely, the dot). If you want just the number back, write this:</p>
<pre>
    tuple : (number dot {$item[1]})(2)</pre>
<p>If you want both number and dot back (in a nested array), write this:</p>
<pre>
    tuple : (number dot {\@item})(2)</pre>
</li>
</ul>
<p>
</p>
<h2><a name="capturing_whitespace_between_tokens">Capturing whitespace between tokens</a></h2>
<p>I need to capture the whitespace between tokens using Parse::RecDescent.
I've tried modifying the $skip expression to // or /\b/ (so I can tokenize
whitespace), but that doesn't seem to have the desired effect.</p>
<p>Just having a variable where all skipped whitespace is stored would be
sufficient.</p>
<p>Does anybody know how to trick Parse::RecDescent into doing this?</p>
<ul>
<li><strong>Answer by Damian Conway</strong>

<p>To turn off whitespace skipping so I can handle it manually, I always use:</p>
<pre>
        &lt;skip:''&gt;</pre>
<p>See:</p>
<pre>
        demo_decomment.pl
        demo_embedding.pl
        demo_textgen.pl</pre>
<p>for examples.</p>
</li>
</ul>
<p>
</p>
<h2><a name="my_grammar_is_not_returning_any_data_">My grammar is not returning any data!</a></h2>
<p>What's wrong?!</p>
<ul>
<li><strong><a name="item_answer_by_brent_dax_3a">Answer by Brent Dax:</a></strong>

<p>This is a clue; either something is wrong with your actions or the
grammar isn't parsing the data correctly. Try adding 
  | &lt;error&gt;</p>
<p>clauses
to the end of each top-level rule. This will tell you if there's a
parsing error, and possibly what the error is. If this doesn't show
anything, look hard at the actions. You may want to explicitly set the
$return variable in the actions.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="things_not_to_do">THINGS NOT TO DO</a></h1>
<p>
</p>
<h2><a name="don_t_think_that_rule__statement_and_rule__statement_1__are_the_same">Don't think that rule: statement and rule: <code>statement(1)</code> are the
same</a></h2>
<p>Even though in pure Perl, the repetition modifier returns the same
data structure without or without an argument of one:</p>
<pre>
 use Data::Dumper;</pre>
<pre>
 my @a = (x);
 my @b = (x) x 1;</pre>
<pre>
 my $x = 'x';
 my $y = 'x' x 1;</pre>
<p>In this first case below, <code>rule_one</code> returns a scalar upon matching, 
while <code>rule_two</code> returns an arrayref with 1 element upon matching:</p>
<pre>
 rule_one: statement
 rule_two: statement(1)</pre>
<p>However counter-intuitive this may at first sound, Damian provides us with 
some insight:</p>
<p>I don't think <code>x</code> is the right analogy for RecDescent repetition operators.
The behaviour of <code>*</code> and <code>+</code> in regexes is a closer model.</p>
<p>I guess it depends on your poitn of view. I would have said that the
absolute consistency with which *every* repetition (regardless of its
number) returns an array ref is better than the alternative:</p>
<pre>
        christmas:
                gold_rings(5)                   # returns array ref
                calling_birds(4)                # returns array ref
                French_hens(3)                  # returns array ref
                turtle_doves(2)                 # returns array ref
                partridge_in_a_pear_tree(1)     # returns scalar value</pre>
<p>Especially if you have to change the count at some later point, which 
would mess up any code relying on the type of value returned.</p>
<p>
</p>
<h2><a name="do_not_follow__resync__with__reject__to_skip_errors">Do not follow &lt;resync&gt; with &lt;reject&gt; to skip errors</a></h2>
<p><code>resync</code> is used to allow a rule which would normally fail to ``pass'' so that 
parsing can continue. If you add the reject, then it unconditionally fails.</p>
<p>
</p>
<h2><a name="do_not_assume_that__item_contains_an_array_ref_of_all_text_matched_for_a_particular_subrule">Do not assume that %item contains an array ref of all text matched for
a particular subrule</a></h2>
<p>For example:</p>
<pre>
        range: '(' number '..' number )'
                        { $return = $item{number} }</pre>
<p>will return only the value corresponding to the last match of the <code>number</code>
subrule.</p>
<p>To get each value for the number subrule, you have a couple of choices,
both documented in the Parse::RecDescent manpage under
<code>@item and %item</code>.</p>
<p>
</p>
<h2><a name="use__rulevar__local__x__not__rulevar___x_">use &lt;rulevar: local $x&gt; not &lt;rulevar: $x&gt;</a></h2>
<p>If you say:</p>
<pre>
        somerule: &lt;rulevar: $x&gt;</pre>
<p>you get a lexical $x within the rule (only). If you say:</p>
<pre>
        somerule: &lt;rulevar: local $x&gt;</pre>
<p>you get a localized $x within the rule (and any subrules it calls).</p>
<p>
</p>
<h2><a name="don_t_use____rd_autoaction_to_print_while_you_are_parsing">Don't use $::RD_AUTOACTION to print while you are parsing</a></h2>
<p>You can't print out your result while you are parsing it, because you
can't ``unprint'' a backtrack.</p>
<p>Instead, have the final top-level rule do all the diagnostic printing, or
alternatively use P::RD's tracing functionality to observe parsing in 
action.</p>
<p>
</p>
<hr />
<h1><a name="error_handling">ERROR HANDLING</a></h1>
<p>
</p>
<h2><a name="propagating_a_failure_up_after_a__commit__on_a_subrule">Propagating a failure up after a &lt;commit&gt; on a subrule</a></h2>
<p>See <a href="#commit_in_subrule_which_is_optional_in_rule">Commit in subrule which is optional in rule</a></p>
<p>
</p>
<h2><a name="in_a_nonshell__e_g__cgi__environment">In a non-shell (e.g. CGI) environment</a></h2>
<p>I need to parse a file with a parser that I cooked up from
Parse::Recdescent. 
My problem, it must work in a cgi environment and the script must be
able to handle errors. I tried eval, piping, forking, Tie::STDERR, but
the errors msgs from Parse::Recdescent seem unstoppable.</p>
<p>I can catch them only by redirecting the script's STDERR from the
shell. But howdo I catch them from within ??</p>
<ul>
<li><strong><a name="item_like_this_3a">Like this:</a></strong>

<pre>
        use Parse::RecDescent;
        open (Parse::RecDescent::ERROR, &quot;&gt;errfile&quot;)
                or die &quot;Can't redirect errors to file 'errfile'&quot;;</pre>
<pre>
        # your program here</pre>
</ul>
<p>
</p>
<h2><a name="accessing_error_data">Accessing error data</a></h2>
<p>What I want to do is export a &lt;error: foo bar&gt; condition to the
calling
program.  Currently _error writes the error message to (what
essentially
is STDOUT) which means a parsing error prints a nice message, but it
is
up to the reader to DO anything about it.</p>
<p>I have a Tk viewer that will parse the file.  When the parse fails, I
would like to capture the line number and error message returned and
position the viewer (a text widget) to that line, highlighted.  And no
STDOUT message.</p>
<p>Something kind of like the eval function where the return value is the
result but $@ is set as a ``side effect''.</p>
<p>Am I missing something about the built in capability?  Is the solution
as simple as overloading the Parse::RecDescent::_error subroutine with
my own copy which might look like this:</p>
<p>%Parse::RecDescent::ERROR=();
...
sub Parse::RecDescent::_error($;$)
{
	$ERRORS++;
	return 0 if ! _verbosity(``ERRORS'');
	%Parse::RecDescent::ERROR=('line'=&gt;$_[1],'msg'=&gt;$_[0]);
	return 1;
}</p>
<p>It seems like it should work and I tried it and it did.  BUT this is
an
extremely complex bit of code and I'm concerned about unforseen
consequences.</p>
<p>Of course, I could make ERROR a my variable and provide a method to
access it so it is not a ``global'', and this would be OO code of a
higher
purity (or something), but that is not really the point.</p>
<ul>
<li><strong>Answer by Damian Conway</strong>

<p>You can get access to the error data by referring to the attribute
<code>$thisparser-</code>{errors}&gt; within a rule.</p>
<p><code>$thisparser-</code>{errors}&gt; is a reference to an array of arrays. Each of
the inner arrays has two elements: the error message, and the line
number.</p>
<p>So, for example, if your top-level rule is:</p>
<pre>
 start: subrule1 subrule2</pre>
<p>then you could intercept any errors and print them to a log file, like
so:</p>
<pre>
 start: subrule1 subrule2
      | { foreach (@{$thisparser-&gt;{errors}}) {
              print LOGFILE &quot;Line $_-&gt;[1]:$_-&gt;[0]\n&quot;;
          }
          $thisparser-&gt;{errors} = undef;
        }</pre>
<p>Note that the line:</p>
<pre>
 $thisparser-&gt;{errors} = undef;</pre>
<p>is doing double duty. By resetting <code>$thisparser-</code>{errors}&gt;, it's
preventing those annoying error messages from being automagically
printed. And by having the value <code>undef</code> as the last value of the
action, it's causing the action to fail, which means the second
production fails, which means the top rule fails, which means errors
still cause the parse to fail and return <code>undef</code>.</p>
</li>
</ul>
<p>
</p>
<h2><a name="simple_error_handling">Simple Error Handling</a></h2>
<p>I'm trying to write a parser for orders for Atlantis (PBEM game).
Syntax is pretty simple: one line per command, each command
starts with name, followed by list of parameters. Basically it's
something like this (grammar for parsing one line):</p>
<pre>
 Statement:Comment | Command Comment(?)
 Comment:/;.*/ 
 Command:'#atlantis' &lt;commit&gt; FactionID String
    Command:'attack' &lt;commit&gt; Number(s)
 ....</pre>
<p>However I have problems to make it work as I want:</p>
<p>1) In case of failed parsing (syntax error, not allowey keyword, ...) 
I want to store error messages in variable (not to be just printed), so I can 
process them later.</p>
<p>I don't think Parse::RecDescent has a hook for that (Damian, something
for the todo list?), but you can always install a $SIG {__WARN__}
handler and process the generated warnings.</p>
<p>2) In case if user types ``attack bastards'' I want to give him
error message that ``list of numbers expected'' instead
of just saying the ``cannot parse this line''. The only
thing that I came up with now was defining every command
like this:
 Command:Attack
 Attack:'attack' AttackParams
 AttackParams:Number(s) | &lt;error&gt;
 ...
Any better solutions?</p>
<ul>
<li><strong><a name="item_you_can_just_do_3a">You can just do:</a></strong>

<pre>
    Command:   '#atlantis' &lt;commit&gt; FactionID String
       |   'attack' &lt;commit&gt; Number(s)
       |   &lt;error&gt;</pre>
<p>and when you try to parse ``attack bastards'', you will get:</p>
<pre>
    ERROR (line 1): Invalid Command: Was expecting Number but found
        &quot;bastards&quot; instead</pre>
<p>You might want to use &lt;error?&gt;, which will only print the error when
it saw '#atlantis' or 'attack' (because then you are committed).</p>
</ul>
<p>
</p>
<h2><a name="collecting_all_error_messages_for_processing">Collecting all error messages for processing</a></h2>
<p>Is there a way to to collect the parser-generated errors and use them later 
on in my script?</p>
<ul>
<li><strong>Answer by Damian</strong>

<p>There's no ``official'' way (yet). A future release will allow you
to create pluggable OO error handlers. At the moment the best 
you can do is:</p>
<pre>
        startrule: try_this
                 | try_that
                 | try_the_other
                 | { ::do_something_with( $thisparser-&gt;{errors} ) }</pre>
<p>$thisparser-&gt;{errors} will contain a reference to an array-of-arrays,
where each inner array contains the error message and the line number
it occurred at.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="other_parse__recdescent_questions">OTHER Parse::RecDescent QUESTIONS</a></h1>
<p>
</p>
<h2><a name="how_to_get_the_old_perl_com_article_to_work">How to get the old perl.com article to work?</a></h2>
<p>Jethro of Perlmonks answers:</p>
<p><a href="http://perlmonks.org/?node_id=786132">http://perlmonks.org/</a></p>
<p>The problem is that <code>return()</code> finishes parsing.</p>
<p>Parse::RecDescent works with a variable <code>$return</code> to give back results from subrules to parent rules. If you change the three occurences of <code>return</code> inside the grammar (but not inside the sub 'expression') to <code>$return=</code> the parser works.</p>
<p>
</p>
<h2><a name="matching_line_continuation_characters">Matching line continuation characters</a></h2>
<p>I need to parse a grammar that includes line continuation
characters.  For example:</p>
<pre>
 // COMMAND ARG1-VALUE,ARG2-VALUE, +
    ARG3-VALUE,ARG4-VALUE, +
    EVEN-MORE-ARGS
 // ANOTHERCOMMAND
 * and a comment
 * or two</pre>
<p>How do I formulate a rule (or rules) to treat the first command
as if all 5 arguments were specified on a single line?  I need to
skip over the /\s*+\n\s*/ sequence.  It seems like skip or resync
should do this for me, but if so, I haven't discovered the
correct technique, yet.</p>
<ul>
<li><strong>Answer by Damian Conway</strong>

<pre>
 use Parse::RecDescent;
 
 my @lines = &lt;&lt; 'EOINST';
 // COMMAND ARG1-VALUE,ARG2-VALUE, +
    ARG3-VALUE,ARG4-VALUE, +
    EVEN-MORE-ARGS
 // ANOTHERCOMMAND
 * and a comment
 * or two
 EOINST
 
 my $parse = Parse::RecDescent-&gt;new(join '', &lt;DATA&gt;) or die &quot;Bad Grammar!&quot;;
 
 use Data::Dumper 'Dumper';
 print Dumper [
 $parse-&gt;Instructions(&quot;@lines&quot;) or die &quot;NOT parsable!!\n&quot;
 ];
 
 __DATA__
 
 Instructions: command(s)
 
 command: multiline_command
        | singleline_command
        | comment
 
 singleline_command: 
        '//'  /.*/
                { {command =&gt; $item[-1]} }
 
 multiline_command:  
        '//' /(.*?[+][ \t]*\n)+.*/
                { $item[-1] =~ s/[+][ \t]*\n//g; {command =&gt; $item[-1]} }
 
 comment:
        '*'  /.*/
                { {comment =&gt; $item[-1]} }</pre>
</ul>
<p>
</p>
<h2><a name="how_can_i_match_parenthetical_expressions_to_arbitrary_depth">How can I match parenthetical expressions to arbitrary depth?</a></h2>
<p>Example: a, (b ,c, (e,f , [h, i], j) )</p>
<ul>
<li><strong><a name="item_answer_by_faq_author">Answer by FAQ author</a></strong>

<p>Maybe Text::Balanced is enough for your needs. See it on search.CPAN.org
under author id DCONWAY.</p>
</li>
<li><strong><a name="item_answer_by_lhoward_of_perlmonks_2eorg_3a">Answer by lhoward of perlmonks.org:</a></strong>

<p>Parse::RecDescent implements a full-featured recursive-descent
parser. A real parser (as opposed to parsing a string with a regular
expression alone) is much more powerful and can be more apropriate for
parsing highly structured/nested data like you have. It 
has been a while since I've written a grammer so it may look a bit
rough.</p>
<pre>
 use Parse::RecDescent;
 my $teststr=&quot;blah1,blah2(blah3,blah4(blah5,blah6(blah7))),blah8&quot;;
 my $grammar = q {
         content:        /[^\)\(\,]+/
         function:       content '(' list ')'
         value:          content
         item:           function | value
         list:           item ',' list | item
         startrule:      list
 };
 my $parser = new Parse::RecDescent ($grammar) or die &quot;Bad grammar!\n&quot;;
 
 defined $parser-&gt;startrule($teststr) or print &quot;Bad text!\n&quot;;</pre>
<p>To which merlyn (Randal Schwartz) of perlmonks.org says:</p>
<p>Simplifying the grammar, we get:</p>
<pre>
 use Parse::RecDescent;  
 my $teststr=&quot;blah1,blah2(blah3,blah4(blah5,blah6(blah7))),blah8&quot;;  
 my $grammar = q {
  list: &lt;leftop: item ',' item&gt; 
  item: word '(' list ')' &lt;commit&gt;
      | word 
  word: /\w+/  
 };  
 my $parser = new Parse::RecDescent ($grammar) or die &quot;Bad grammar!\n&quot;;
 
 defined $parser-&gt;list($teststr) or print &quot;Bad text!\n&quot;;</pre>
<p></p>
</li>
</ul>
<p>
</p>
<h2><a name="switching_out_of_firstmatchwins_mode">Switching out of first-match-wins mode</a></h2>
<p>I have a set of alternatives on which I want to avoid the
default first-match-wins behavior of Parse::RecDescent. How do I do
it?</p>
<ul>
<li><strong>Answer by FAQ author</strong>

<p>Use a scored grammar. For example, this scoring directive</p>
<pre>
 opcode: /$match_text1/  &lt;score: { length join '' @item}&gt;
 opcode: /$match_text2/  &lt;score: { length join '' @item}&gt;
 opcode: /$match_text3/  &lt;score: { length join '' @item}&gt;</pre>
<p>would return the opcode with the longest length, as opposed to which
one matched first.</p>
<p>Just look for the section ``Scored productions'' in the .pod
documentation.</p>
</li>
</ul>
<p>
</p>
<h2><a name="i_m_having_problems_with_the_intertoken_separator_">I'm having problems with the inter-token separator:</a></h2>
<pre>
 my $parse = Parse::RecDescent-&gt;new(&lt;&lt;'EndGrammar');</pre>
<pre>
 rebol   : block  { dump_item('block', \@item)  }
         | scalar { dump_item('scalar', \@item) }</pre>
<pre>
 block       : '[' block_stuff(s?) ']'
 block_stuff : scalar
 scalar      : &lt;skip:''&gt; '%' file
 file        : /w+/</pre>
<pre>
 EndGrammar</pre>
<p>My grammar matches a filename, ie:</p>
<pre>
 %reb.html</pre>
<p>just fine. However, it does not match a filename within a block, ie:</p>
<pre>
 [ %reb.html ]</pre>
<p>and I know exactly why after tracing the grammar.</p>
<p>It is trying the</p>
<pre>
 &lt;skip:''&gt; '%' file</pre>
<p>production with the input text</p>
<pre>
 &quot; %reb.html&quot;</pre>
<p>note the space in the input text.</p>
<p>The reason this distresses me is that I have not changed the universal token 
separator from</p>
<pre>
 /\s*/</pre>
<p>Yet it did not gobble up the white space between the '[' terminal and the &lt;skip:''&gt;'%' file production</p>
<ul>
<li><strong>Answer by Randal Schwartz</strong>

<p>That's the expected behavior. The outer prefix is in effect until
changed, but you changed it early in the rule, so the previous
``whitespace skip'' is effectively gone by the time you hunt for '%'.</p>
<p>To get what you want, you want:</p>
<pre>
 '%' &lt;skip:''&gt; file</pre>
<p>in your rule. 
back</p>
</li>
</ul>
<p>
</p>
<h2><a name="matching_blank_lines">Matching blank lines</a></h2>
<p>How do I match an arbitrary number of blank lines in Parse::RecDescent?</p>
<ul>
<li><strong>Answer by Damian Conway</strong>

<p>Unless you use the /m suffix, the trailing $ means ``end of string'', 
not ``end of line''. You want:</p>
<pre>
   blank_line:  /^\s+?$/m</pre>
<p>or 
</p>
<pre>

   blank_line:  /^\s+?\n/</pre>
</li>
</ul>
<p>I have a rule which MUST be failing, but it isn't. Why?</p>
<pre>
   blank_line:    { $text =~ /silly-regex/ }
   
          parses with no error.</pre>
<ul>
<li><strong>Answer by Damian Conway</strong>

<p>The pattern match still fails, but returns the empty string (``'').
Since that's not undef, the rule matches (even though it doesn't
do what you want).</p>
</li>
</ul>
<p>
</p>
<h2><a name="how_can_i_get_at_the_text_remaining_to_be_parsed">How can I get at the text remaining to be parsed?</a></h2>
<p>See the documentation for the <code>$text</code> variable.</p>
<p>
</p>
<h2><a name="you_don_t_escape_perl_symbols_in_your_grammars__why_did_i_have_to">You don't escape Perl symbols in your grammars. Why did I have to?</a></h2>
<pre>
 my $grammar = &lt;&lt;EOGRAMMAR;
 
 export_line:   stock_symbol    COMMA   # 1
                stock_name      COMMA2  # 2
                stock_code      COMMA3  # 3
                trade_side      COMMA4  # 4
                trade_volume    COMMA5  # 5
                floating_point  COMMA6  # 6
                tc                      # 7
 { print &quot;got \@item\n&quot;; }
     | &lt;error&gt;
 EOGRAMMAR
 
 Why does '@' have to be escaped? And whatever reason
 that may be, why doesnt it apply to '\n'?</pre>
<ul>
<li><strong>Answer by Damian Conway</strong>

<p>Because you're using an interpolating here document. You almost certainly 
want this instead:</p>
<pre>
 my $grammar = &lt;&lt;'EOGRAMMAR';           # The quotes are critical!
    
 
  export_line:  stock_symbol    COMMA   # 1
                stock_name      COMMA2  # 2
                stock_code      COMMA3  # 3
                trade_side      COMMA4  # 4
                trade_volume    COMMA5  # 5
                floating_point  COMMA6  # 6
                tc                      # 7
  { print &quot;got @item\n&quot;; }
     | &lt;error&gt;
 EOGRAMMAR</pre>
</li>
</ul>
<p>
</p>
<h2><a name="other_modules_appear_to_not_work_when_used_with_p__rd">Other modules appear to not work when used with P::RD</a></h2>
<p>Such-and-such a module works fine when I don't use Parse::RecDescent</p>
<ul>
<li><strong>Answer by Damian Conway</strong>

<pre>
 Did you alter the value of undef with your parser code?</pre>
<p>The problem has nothing to do with  Parse::RecDescent.
</p>
<pre>

Rather, it was caused by your having set $/ to undef, which seems to
have caused Mail::POP3 to over-read from its socket (that might be
considered a bug in the Mail::POP3 module).</pre>
<p>As a rule-of-thumb, *never* alter $/ without local-izing it. In other words, 
change things like this:</p>
<pre>
         $/ = undef;</pre>
<p>to this:</p>
<pre>
          {
          local $/;
          }</pre>
</ul>
<p>
</p>
<hr />
<h1><a name="programming_topics_germane_to_parse__recdescent_use">PROGRAMMING TOPICS GERMANE TO Parse::RecDescent USE</a></h1>
<p>
</p>
<h2><a name="getting_large_files_into_memory">Getting large files into memory</a></h2>
<p>An issue related to PRD is how to get huge files into memory for parsing. 
Check out this link:</p>
<p><a href="http://perlmonks.org/?node_id=636233">http://perlmonks.org/</a></p>
<p>for some approaches to this problems.</p>
<p>
</p>
<h2><a name="double_vs_singlequoted_strings">Double vs Single-quoted strings</a></h2>
<p>I'm playing around with the &lt;skip:&gt; directive and I've noticed
something interesting that I can't explain to myself.</p>
<p>Here is my script:</p>
<p>Program fragment delivered error ``couldnt open file : No such file or directory at ./tt.pl line 18, &lt;F&gt; line 332.''</p>
<p>This script works great. However, if I change the value of the skip
directive so that it uses double quotes instead of single quotes:</p>
<pre>
    &lt;skip: &quot;\.*&quot;&gt;</pre>
<p>the grammar fails to parse the input. However, if I put square
brackets around the escaped dot:</p>
<pre>
    &lt;skip: &quot;[\.]*&quot;&gt;</pre>
<p>the grammar starts working again:</p>
<p>How does this work this way?</p>
<ul>
<li><strong><a name="item_damian_says_3a">Damian says:</a></strong>

<p>This small test program may help you figure out what's going wrong:</p>
<pre>
        print &quot;\.*&quot;, &quot;\n&quot;;
        print '\.*', &quot;\n&quot;;</pre>
<p>Backslash works differently inside single and double quotes.
Try:</p>
<pre>
      &lt;skip: &quot;\\.*&quot;&gt;</pre>
<p>The reason the third variant:</p>
<pre>
      &lt;skip: &quot;[\.]*&quot;&gt;</pre>
<p>works is because it becomes the pattern:</p>
<pre>
        /[.]/</pre>
<p>which is a literal dot.</p>
</li>
</ul>
<p>
</p>
<h2><a name="tracking_text_parsed_between_phases_of_the_parse">Tracking text parsed between phases of the parse</a></h2>
<p>I wanted to know, after matching a rule, what text the rule matched.
So I used two variables to remember what the remaining text and
offset were before and after the rule and just determined the
difference.</p>
<pre>
   report : &lt;rulevar: local $rule_text&gt;
   report : &lt;rulevar: local $rule_offset&gt;</pre>
<pre>
   report :
             {
                 $rule_text   = $text;
                 $rule_offset = $thisoffset;
             }</pre>
<pre>
         ...some subrules...</pre>
<pre>
             {
                 my $str = substr($rule_text, 0, $thisoffset - 
$rule_offset);</pre>
<pre>
                 # remove all sorts of whitespace</pre>
<pre>
                 $str =~ s/^\s*//s;
                 $str =~ s/\s*$//s;
                 $str =~ s/\s+/ /gs;</pre>
<pre>
                 # Now $str contains the text matched by this rule
             }</pre>
<p>This is the kind of thing I thought would have been possible a lot
easier. Did I miss something?</p>
<p>If not, is there a way to make this available in every parser,
e.g. by providing a new directive or something like that?</p>
<ul>
<li><strong><a name="item_the_answer_is_on_cpan">The answer is on CPAN</a></strong>

<p>Parse::RecDescent::Consumer, on CPAN, prints out the text consumed
between stages of a parse... even if that part may fail later. The
implementation is straightforward, it creates closures containing
<code>$text</code> and evaluates them later to get the text consumed.</p>
</li>
</ul>
<p>
</p>
<h2><a name="unconditionally_listifying_scalars">Unconditionally listifying scalars</a></h2>
<p>Quite often when using Parse::RecDescent, I want to treat the return value of 
a production the same regardless of whether P::RD returns a string or a 
list of string.</p>
<ul>
<li><strong><a name="item_use_scalar_3a_3alistify_from_cpan_2e">Use Scalar::Listify from CPAN.</a></strong>

</ul>
<p>
</p>
<h2><a name="shallow_versus_deep_copying">Shallow versus Deep Copying</a></h2>
<p>
</p>
<h3><a name="an_article_by_randal_schwartz">An article by Randal Schwartz</a></h3>
<pre>
    L&lt;<a href="http://www.stonehenge.com/merlyn/UnixReview/col30.html&gt">http://www.stonehenge.com/merlyn/UnixReview/col30.html&gt</a>;</pre>
<p>
</p>
<h3><a name="a_tutorial_written_by_philip_newton__nospam_newton_gmx_li_">A tutorial written by Philip Newton &lt;<a href="mailto:nospam.newton@gmx.li">nospam.newton@gmx.li</a>&gt;</a></h3>
<p>Start off with an array of (references to) arrays:</p>
<pre>
    @array = ( [1,2,3], ['a', 'u', 'B', 'Q', 'M'], ['%'] );</pre>
<p>Now a shallow copy looks like this:</p>
<pre>
    @shallow = ( $array[0], $array[1], $array[2] );</pre>
<p>This copies the references over from @array to @shallow. Now @shallow
is ( [1,2,3], ['a', 'u', 'B', 'Q', 'M'], ['%'] ) -- the same as
@array. But there's only one 2 and one 'Q', since there are two
references pointing to the same place.</p>
<p>Here's what it looks like in the debugger:</p>
<pre>
  DB&lt;5&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'B'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
  DB&lt;6&gt; x \@shallow
 0  ARRAY(0xcaef60)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'B'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'</pre>
<p>You can see that @array lives somewhere around 0x10e5560, whereas
@shallow lives around 0xcaef60, but the three references point to
arrays in the same place. If I now change $array[1][2] to 'C', watch
what happens:</p>
<pre>
  DB&lt;7&gt; $array[1][2] = 'C'</pre>
<pre>
  DB&lt;8&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
  DB&lt;9&gt; x \@shallow
 0  ARRAY(0xcaef60)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'</pre>
<p>$shallow[1][2] is now also 'C'! This is because it just followed the
pointer to the array at 0x10e5638 and found the modified data there.</p>
<p>Now see what happens when I do a copy that's one level deeper -- not
just copying the references but the data behind the references:</p>
<pre>
 @deep = ( [ @{$array[0]} ], [ @{$array[1]} ], [ @{$array[2]} ] );</pre>
<p>This uses the knowledge that @array[0..2] are all references to
arrays, and it only goes one level deeper. A more general algorithm
(such as Storable's dclone, mentioned in `perldoc -q copy`) would do a
walk and copy differently depending on the type of reference it
encounters at each stage.</p>
<p>Now watch:</p>
<pre>
  DB&lt;12&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
  DB&lt;13&gt; x \@deep
 0  ARRAY(0x10ef89c)
   0  ARRAY(0x10eb298)
      0  1
      1  2
      2  3
   1  ARRAY(0x10eb2c4)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10ef07c)
      0  '%'</pre>
<p>The references point to different places.</p>
<p>Now if you change @array, @deep doesn't change:</p>
<pre>
  DB&lt;14&gt; push @{$array[2]}, '$'</pre>
<pre>
  DB&lt;15&gt; x \@array
 0  ARRAY(0x10e5560)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
      1  '$'
  DB&lt;16&gt; x \@shallow
 0  ARRAY(0xcaef60)
   0  ARRAY(0x10e5464)
      0  1
      1  2
      2  3
   1  ARRAY(0x10e5638)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10e568c)
      0  '%'
      1  '$'
  DB&lt;17&gt; x \@deep
 0  ARRAY(0x10ef89c)
   0  ARRAY(0x10eb298)
      0  1
      1  2
      2  3
   1  ARRAY(0x10eb2c4)
      0  'a'
      1  'u'
      2  'C'
      3  'Q'
      4  'M'
   2  ARRAY(0x10ef07c)
      0  '%'</pre>
<p>@deep didn't change, since it's got its own value of the anonymous
array containing '%', but @shallow did.</p>
<p>Hope this helps a bit.</p>
<p>Cheers, Philip -- Philip Newton &lt;<a href="mailto:nospam.newton@gmx.li">nospam.newton@gmx.li</a>&gt; 
If you're not part of the solution, you're part of the precipitate</p>
<p>
</p>
<h2><a name="apparent__but_not_really_deep_copying__my___list____________0_____">Apparent, but not really deep copying:  my (@list) = @{[@{$_[0]}]};</a></h2>
<p>I was meandering through demo_calc.pl in the Parse::RecDescent demo
directory and came across this</p>
<pre>
 sub evalop
 {
        my (@list) = @{[@{$_[0]}]};
        my $val = shift(@list)-&gt;();
 ...       
 }</pre>
<p>I took the line that confused me step-by-step and don't get the
purpose of this. Working from inner to outer:</p>
<pre>
   @{$_[0]}     # easy --- deference an array reference
 [  @{$_[0]} ]    # ok --- turn it back into an array ref.. why?
 @{ [ @{$_[0]} ] } # umm -- uh.... well, the @sign implies
                             # we have an array, but how is it 
                             # different from the first array we
                             # dereferenced?</pre>
<ul>
<li><strong><a name="item_matthew_wickerline_says">Matthew Wickerline says</a></strong>

<p>The line from demo_calc.pl is in
fact not doing any deep copying.</p>
<pre>
    #!/usr/bin/perl -w
    my @original = (
        [0],  [1,2,3],  [4,5,6],  [7,8,9]
    );
    my @copy = &amp;some_kind_of_copy( \@original );
    sub some_kind_of _copy {
        # here's that line from demo_calc.pl
        my (@list) = @{[@{$_[0]}]};
        return @list;
    }</pre>
<pre>
 $original[0][0]         = 'zero';
 @{ $original[1] }[0..2] = qw(one   two   three);
 @{ $original[2] }[0..2] = qw(four  five  six);
 @{ $original[3] }[0..2] = qw(seven eight nine);
    # now use the debugger to look at the addresses,
    # or use Data::Dumper to look at @copy, or just
    # compare one of the items...
 if (  $copy[1][2] eq 'three'  ) {
    print &quot;Shallow Copy\n&quot;;
 } elsif (  $copy[1][2] == 3  ) {
    print &quot;Deep Copy\n&quot;;
 } else {
        print &quot;This should never happen!!!\n&quot;
        }</pre>
<p>If you wanted that line to do deep copying of a list of anon arrays,
then the line should read</p>
<pre>
    my @list = map  { [@$_] }  @{$_[0]};
               # turn $_[0] into a list (of arrayrefs)
               # turn each (arrayref) element of that list
               # into an anonymous array containing
               # a list found by derefrencing the arrarref</pre>
<p>Try plugging that line into above script instead of the line from the
demo_calc.pl and you'll see different output. The line from demo_calc.pl
is in fact doing extra useless work. My guess is that the extra
    @{[    ]}
around there is one of two things:
    1) a momentary lapse of attention
       resulting in a copy/paste error, or duplicate typing
 or
    2) an artifact of earlier code wherein something extra was
       going on in there and has since been deleted.</p>
<p>Even Damian can make a mistake, but it's not a mistake that affects
output... it just makes for a tiny bit of wasted work (or maybe Perl is
smart enough to optimze away the wasted work, I dunno).</p>
</li>
<li><strong><a name="item_damian_conway_says_3a">Damian Conway says:</a></strong>

<p>I have no recollection of why I did this (see children, that's
why you should *always* comment your code!).</p>
<p>I *suspect* it's vestigal -- from a time when contents of the
argument array reference were somehow modified in situ, but
it was important that the original argument's contents not
be changed.</p>
<p>The ungainly <code>@{[@{$_[0]}]}</code> syntax is a way of (shallow)
copying the array referenced in $_[0] without declaring a new
variable. So another possible explanation is that evalop may
originally have been a one-liner, in which case I might have
used this ``inlined copy'' to keep the subroutine's body to a
single expression.</p>
<p>However...</p>
<pre>
   Even Damian can make a mistake</pre>
<p>is by far the likeliest explanation.</p>
</li>
</ul>
<p>
</p>
<h2><a name="regular_expressions">Regular Expressions</a></h2>
<p>
</p>
<h3><a name="shortest_match_instead_of_longest_match">Shortest match instead of longest match</a></h3>
<p>What is the Perl idiom for getting the leftmost shortest match?
For instance, so:</p>
<pre>
 $a = &quot;banana&quot;;
 $a =~ /b.*n/;  # but different
 print $&amp;;</pre>
<p>yields <code>banan</code>. How can I get it to yield
<code>ban</code>?</p>
<ul>
<li><strong><a name="item_just_use_the_non_2dgreedy_quantifier_modifier_2c__">Just use the non-greedy quantifier modifier, <code>?</code> :</a></strong>

<pre>
    $a =~ /b.*?n/;</pre>
</ul>
<p>
</p>
<h3><a name="tutorial_on_positive_and_negative_lookahead_and_lookbehind_regexps_">Tutorial on positive and negative lookahead and lookbehind
regexps:</a></h3>
<pre>
 <a href="http://lists.isb.sdnpk.org/pipermail/comp-list/2002-August/001156.html">http://lists.isb.sdnpk.org/pipermail/comp-list/2002-August/001156.html</a></pre>
<p>
</p>
<h3><a name="japhy_s_book_on_regular_expressions">Japhy's Book on Regular Expressions</a></h3>
<p>Ok, so he hasn't named it yet. It's available online for free!</p>
<pre>
  <a href="http://japhy.perlmonk.org/book">http://japhy.perlmonk.org/book</a></pre>
<p>
</p>
<h3><a name="mastering_regular_expressions_by_jeffrey_freidl">``Mastering Regular Expressions'' by Jeffrey Freidl</a></h3>
<p>You still need to know when to use <code>/.*/</code> or <code>/.+/</code> or <code>/[^x]*/</code></p>
<p>
</p>
<hr />
<h1><a name="perlmonks_nodes">Perlmonks Nodes</a></h1>
<p>Basically the number of posts on Perlmonks about Parse::RecDescent are
growing faster than I have time to study them closely and categorize
them. But it is important that you have rapid access to them instead
of slogging through Super Search or a google site search, so here you
go:</p>
<ul>
<li><strong><a name="item_pro_teaches_amateur">Pro teaches amateur</a></strong>

<p><a href="http://perlmonks.org/?node_id=674283|http://perlmonks.org/?node_id=674283">http://perlmonks.org/</a></p>
<p>Perlmonk Ikegami gives a wonderful set of best practices for
Recdescent usage.</p>
</li>
</ul>
<p>
</p>
<hr />
<h1><a name="resources">RESOURCES</a></h1>
<p>
</p>
<h2><a name="web_links">Web Links</a></h2>
<p>
</p>
<h3><a name="some_parse__recdescent_tutorials">``Some Parse::RecDescent Tutorials''</a></h3>
<p><a href="http://perlmonks.org/?node_id=108182">http://perlmonks.org/</a></p>
<p>
</p>
<h3><a name="craig_s_parse__recdescent_area">Craig's Parse::Recdescent Area</a></h3>
<p>Contains an article (in English)  published during the Zweiter Perl Workshop
as well as some slides for a presentation:</p>
<pre>
     <a href="http://www.informatik.uni-trier.de/~smith/perl/recdescent/">http://www.informatik.uni-trier.de/~smith/perl/recdescent/</a>
    
=head3 Hugh Myer's tips on Parse::RecDescent</pre>
<pre>
    <a href="http://www.perlmonks.org/index.pl?node_id=180778">http://www.perlmonks.org/index.pl?node_id=180778</a></pre>
<p>17 tips you cannot do without... recently updated!</p>
<p>
</p>
<h3><a name="parse__recdescent_tutorial_at_www_perl_com">Parse::Recdescent tutorial at www.perl.com</a></h3>
<p><a href="http://www.perl.com/pub/a/2001/06/13/recdecent.html">http://www.perl.com/pub/a/2001/06/13/recdecent.html</a></p>
<p>Yes, I see the mis-spelling, but the link works. And in the Perl community,
we are all about pragmatism!</p>
<p>
</p>
<h2><a name="published_articles_and_books">Published articles and books</a></h2>
<p>
</p>
<h3><a name="parse_data__dumper_output">Parse Data::Dumper output</a></h3>
<p>In the Linux Magazine article ``Safe undumping'' by Randal Schwartz uses
Parse::RecDescent to parse Data::Dumper output. Not fast, but quite
complete.</p>
<p>
</p>
<h3><a name="parsing_interesting_things">``Parsing Interesting Things''</a></h3>
<p>SysAdminMag.COM, December 2001, Randal Schwartz</p>
<p>
</p>
<h3><a name="data_munging_with_perl_by_dave_cross">``Data Munging with Perl'' by Dave Cross</a></h3>
<p>Chapter 11 is focused on parsing with special emphasis on practical use of
Parse::RecDescent.</p>
<p>
</p>
<h3><a name="objectoriented_perl_by_damian_conway">``Object-Oriented Perl'' by Damian Conway</a></h3>
<p>This book will aid you in complexity management for large grammars.</p>
<p>
</p>
<h2><a name="cpan_modules_of_wonderful_utility_">CPAN Modules of Wonderful Utility!</a></h2>
<p>
</p>
<h3><a name="data__match">Data::Match</a></h3>
<p><a href="/Data/Match.html">Data::Match</a> is an excellent tool for parse tree foraging.
A typical autoaction is 
  $::RD_AUTOACTION = q { [@item] } ;</p>
<p>which leads to deeply nested parse trees.</p>
<p>I first inquired about various tools for spelunking in such trees:
  <a href="http://perlmonks.org/?node_id=646560">http://perlmonks.org/?node_id=646560</a></p>
<p>And am very happy so far with Data::Match. Here is a sample parse tree
from my parse:</p>
<pre>
 $VAR1 = [
          'simple_house',
          [
            'pre_simple',
            [
              'geoloc',
              [
                'geoloc_',
                [
                  'place',
                  [
                    'city',
                    'taipei'
                  ]
                ]
              ]
            ]
          ],
          [
            'house',
            'house'
          ],
          []
        ];</pre>
<p>Now, my goal is to get at the inner-most array in $VAR1-&gt;[1]:</p>
<pre>
    [
                    'city',
                    'taipei'
    ]</pre>
<p>And with Data::Match, I can do so in a very definitional fashion:</p>
<pre>
 my $match = match
    (
     # The parse tree
     $self-&gt;{parse_result}[1], 
 
     # The Data::Match pattern match template
     FIND ( 
           COLLECT (
                    'x',
                    [ 
                     EXPR(q{! ref}),
                     EXPR(q{! ref})</pre>
<pre>
                    ]
                    )
           )
    );</pre>
<p>The pattern is basically saying: ``match an array ref consisting of 2
elements where each element is not an reference of any sort''. Since
the strings 'city' and 'taipei' both fulfill that criterion that is
what matches.</p>
<p>
</p>
<h3><a name="data__multivaluedhash">Data::MultiValuedHash</a></h3>
<p>Transparent manipulation of single or multiple-valued Perl hash values.</p>
<p>
</p>
<h3><a name="parse__recdescent__consumer">Parse::RecDescent::Consumer</a></h3>
<p><a href="/Parse/RecDescent/Consumer.html">Parse::RecDescent::Consumer</a> 
makes it easy to keep track of how much
text has been consumed through successful matches.</p>
<p>
</p>
<h3><a name="regexp__list__part_of_regexp__optimizer_">Regexp::List (part of Regexp::Optimizer)</a></h3>
<p>If you have a lot of alternations, it will be more efficient to
test a single pre-compiled, optimized regular expression than a bunch of 
strings. And <a href="/Regexp/List.html">Regexp::List</a> is designed to help you do
just that.</p>
<p>
</p>
<h3><a name="regexp_assemble">Regexp:Assemble</a></h3>
<p><a href="/Regexp/Assemble.html">Regexp:Assemble</a> is a similar tool to Regexp::List,
except that instead of just providing plain strings, you can give it 
a series of regular expressions, for it to assemble into one large
regular expression.</p>
<p>
</p>
<h3><a name="text__balanced_and_regexp__common__balanced">Text::Balanced  and Regexp::Common::balanced</a></h3>
<p>Use this instead of writing hairy regular expressions to match certain
common ``balanced'' forms of text, such as tags and parenthesized text.</p>
<p>See <a href="http://perlmonks.org/index.pl?node_id=208285">http://perlmonks.org/index.pl?node_id=208285</a>
for an example of where it would be better suited for the task than
Parse::RecDescent.</p>
<p>
</p>
<h3><a name="scalar__listify">Scalar::Listify</a></h3>
<p>Sometimes in grammars, you are not sure if you will end up with a scalar
match or an array of results. But you will often want to process them both 
the same. <a href="/Scalar/Listify.html">Scalar::Listify</a> facilitates this process.</p>
<p>
</p>
<h2><a name="practical_parser_examples">Practical Parser Examples</a></h2>
<p>
</p>
<h3><a name="dbfeeder___data__generate__database_test_data_generation_tool">DBFeeder / Data::Generate - database test data generation tool</a></h3>
<p><a href="http://dbfeeder.sourceforge.net/|http://dbfeeder.sourceforge.net/">http://dbfeeder.sourceforge.net/|http://dbfeeder.sourceforge.net/</a>
is a a powerful data generation tool. Internally, it uses
<a href="/Data/Generate.html">Data::Generate</a> to parse ``inverted regular expressions'' 
using Parse::RecDescent.</p>
<p>
</p>
<h4><a name="tangential_new_directions">Tangential new directions</a></h4>
<p>In a recent perlmonks thread:
<a href="http://perlmonks.org/?node_id=672163|http://perlmonks.org/?node_id=672163">http://perlmonks.org/</a> 
the author of DBFeeder (Davide Conti) discusses SQL parsing with 
Parse::RecDescent (among other tools). This technology is not currently
a part of DBFeeder and Data::Generate, but an avenue he is exploring.</p>
<p>
</p>
<h3><a name="article_comparing_gene_parsing_with_prd_and_other_approaches">Article comparing Gene Parsing with PRD and other approaches</a></h3>
<p>``The Making of Entrez Gene parsers in Perl using
Parse::RecDescent, Parse::Yapp, Perl-byacc and Regex'' by
Dr. Mingyi Liu</p>
<p>is available from:</p>
<p><a href="http://sourceforge.net/docman/display_doc.php?docid=27420&group_id=133629">http://sourceforge.net/docman/display_doc.php</a></p>
<p>
</p>
<h3><a name="module_dependency_expression_parser">Module dependency expression parser</a></h3>
<p>This code by Marc Prewitt was a response to 
Mark Dominus' Perl 'Expert' Quiz of the Week #24 (Module dependency
evaluation). This quiz of the week was a practical challenge to find
code that could end up useable within Module::Build. The requirement
was to allow for the module prerequisite to be specified using boolean
logic, e.g.:</p>
<pre>
        requires =&gt; q[
                 (DBD::Pg &amp;&amp; DateTime::Format::Pg)
                   ||
                 (DBD::mysql &amp;&amp; DateTime::Format::mysql)
             ]</pre>
<p>If we need to, we can also include version specifications:</p>
<pre>
             requires =&gt; q[
                 ( DBD::Pg &gt; 1.1 &amp;&amp; DateTime::Format::Pg )
                   ||
                 ( DBD::mysql &lt;= 1.2 &amp;&amp; DateTime::Format::mysql )
             ]</pre>
<p>The neat thing about the solution is that after coding it, Marc had
PRD generate a parser that ran independantly from PRD itself.</p>
<p>This solution, according to the judge, ``... is
probably the best solution to use if full expression parsing is
desired for Module::Build.''</p>
<p>Marc's outline of his solution and link to full code is available
here:</p>
<pre>
        <a href="http://perl.plover.com/~alias/list.cgi?1:mss:2279:homdmfmmaelddeehiooi">http://perl.plover.com/~alias/list.cgi?1:mss:2279:homdmfmmaelddeehiooi</a></pre>
<p>
</p>
<h3><a name="xsh__the_xml_editing_shell">XSH - The XML Editing Shell</a></h3>
<p>XSH:</p>
<p><a href="http://xsh.sourceforge.net/">http://xsh.sourceforge.net/</a></p>
<p>uses Parse::RecDescent</p>
<p>
</p>
<h3><a name="parsing_symbolic_expressions___boolean_logic">Parsing Symbolic Expressions / Boolean Logic</a></h3>
<p>Says Stefan Mueller:</p>
<p>Parse::RecDescent can easily parse such expressions. 
You can find a working example grammar for more involved 
*arithmetic* expressions in the <a href="/Math/Symbolic/Parser.html">the Math::Symbolic::Parser manpage</a> module that is 
part of the <a href="/Math/Symbolic.html">the Math::Symbolic manpage</a> distribution. 
It should be fairly easy to modify it to work for boolean logic.</p>
<p>
</p>
<h3><a name="mysql_to_oracle_schema_conversion_utility">MySql to Oracle schema conversion utility</a></h3>
<p>Written in Parse::RecDescent by Tim Bunce:</p>
<p><a href="http://groups.google.com/groups?q=recdescent&start=40&hl=en&scoring=d&rnum=41&selm=9km7b1%246vc%241%40FreeBSD.csie.NCTU.edu.tw">http://groups.google.com/groups</a></p>
<p>
</p>
<h2><a name="other_parsing_engines">Other Parsing Engines</a></h2>
<p>
</p>
<h3><a name="py">py</a></h3>
<p>py, which I assume is short for <code>parse yacc</code>, is a program by
Mark-Jason Dominus which parses GNU Bison output to produce Perl parsers.</p>
<p>It is obtainable from <a href="http://perl.plover.com/py/">http://perl.plover.com/py/</a></p>
<p>
</p>
<h3><a name="parse__yapp">Parse::YAPP</a></h3>
<p>A bottom-up parser which will be familiar to those who
have used Lex and Yacc. Parse::RecDescent is a top-down parser.</p>
<p>
</p>
<h3><a name="parse__earley">Parse::Earley</a></h3>
<p><a href="/Parse/Earley.html">the Parse::Earley manpage</a></p>
<p>
</p>
<h3><a name="perl6__rules">Perl6::Rules</a></h3>
<p><a href="/Perl6/Rules.html">the Perl6::Rules manpage</a></p>
<p>
</p>
<h3><a name="perlbyacc">perl-byacc</a></h3>
<p><a href="http://www.instantweb.com/D/dictionary/foldoc.cgi?perl-byacc">http://www.instantweb.com/D/dictionary/foldoc.cgi</a></p>
<p>
</p>
<h3><a name="domainspecific_parsers">Domain-specific parsers</a></h3>
<p>On CPAN there are many parsers for particular tasks such as CSV, HTML,
XML, etc.</p>
<p>
</p>
<h2><a name="a_vim_syntax_file_for_parse__recdescent">a VIM Syntax File for Parse::RecDescent</a></h2>
<p><a href="http://perlmonks.org/?node_id=648073">http://perlmonks.org/</a> provides a VIM syntax file for
prd.</p>
<p>
</p>
<hr />
<h1><a name="appendix">APPENDIX</a></h1>
<p>
</p>
<h2><a name="author">Author</a></h2>
<p>The author of Parse::RecDescent is Damian Conway.</p>
<p>The author of Parse::RecDescent::FAQ is Terrence Brannon &lt;<a href="mailto:tbone@cpan.org">tbone@cpan.org</a>&gt;. 
<a href="http://www.metaperl.org">http://www.metaperl.org</a></p>
<p>The (unwitting) contributors to this FAQ</p>
<ul>
<li><strong><a name="item_chas_owens">Chas Owens</a></strong>

<li><strong><a name="item_brent_dax">Brent Dax</a></strong>

<li><strong><a name="item_damian_conway">Damian Conway</a></strong>

<li><strong><a name="item_gwynn_judd">Gwynn Judd</a></strong>

<li><strong><a name="item_lhoward_of_perlmonks">lhoward of Perlmonks</a></strong>

<li><strong><a name="item_marcel_grunaer">Marcel Grunaer</a></strong>

<li><strong><a name="item_matthew_wickline">Matthew Wickline</a></strong>

<li><strong><a name="item_schwartz">Randal L. Schwartz (merlyn), Perl hacker</a></strong>

<li><strong><a name="item_stefan_mueller">Stefan Mueller</a></strong>

<li><strong><a name="item_yves_orton">Yves Orton</a></strong>

</ul>
<p>
</p>
<h2><a name="sources_for_faq_material">Sources for FAQ Material</a></h2>
<p>I try to regularly scan all sources of Perl question-answer for FAQ material.
If you can think of another source that is not listed below, I would
appreciate knowing about it.</p>
<ul>
<li><strong><a name="item_comp_2elang_2eperl_2emodules">comp.lang.perl.modules</a></strong>

<li><strong><a name="item_comp_2elang_2eperl_2emoderated">comp.lang.perl.moderated</a></strong>

<li><strong><a name="item_recdescent_40perl_2eorg"><a href="mailto:recdescent@perl.org">recdescent@perl.org</a></a></strong>

<p>Conveniently available via NNTP at:</p>
<pre>
     <a href="news://nntp.perl.org/perl.recdescent">news://nntp.perl.org/perl.recdescent</a></pre>
</li>
<li><strong><a name="item_perlmonks_2eorg">perlmonks.org</a></strong>

</ul>
<p>
</p>
<hr />
<h1><a name="faq_repo">FAQ repo</a></h1>
<p><a href="http://github.com/metaperl/Parse--RecDescent--FAQ/tree/master">http://github.com/metaperl/Parse--RecDescent--FAQ/tree/master</a>

</p>

</body>

</html>
